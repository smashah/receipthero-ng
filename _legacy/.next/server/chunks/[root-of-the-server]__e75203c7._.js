module.exports=[38631,(e,t,s)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={},c={Analytics:()=>d};for(var l in c)n(a,l,{get:c[l],enumerable:!0});t.exports=((e,t,s,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of r(t))o.call(e,c)||c===s||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),a);var h=`
local key = KEYS[1]
local field = ARGV[1]

local data = redis.call("ZRANGE", key, 0, -1, "WITHSCORES")
local count = {}

for i = 1, #data, 2 do
  local json_str = data[i]
  local score = tonumber(data[i + 1])
  local obj = cjson.decode(json_str)

  local fieldValue = obj[field]

  if count[fieldValue] == nil then
    count[fieldValue] = score
  else
    count[fieldValue] = count[fieldValue] + score
  end
end

local result = {}
for k, v in pairs(count) do
  table.insert(result, {k, v})
end

return result
`,u=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1]) -- First timestamp to check
local increment = tonumber(ARGV[2])       -- Increment between each timestamp
local num_timestamps = tonumber(ARGV[3])  -- Number of timestampts to check (24 for a day and 24 * 7 for a week)
local num_elements = tonumber(ARGV[4])    -- Number of elements to fetch in each category
local check_at_most = tonumber(ARGV[5])   -- Number of elements to check at most.

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

-- select num_elements many items
local true_group = {}
local false_group = {}
local denied_group = {}
local true_count = 0
local false_count = 0
local denied_count = 0
local i = #result - 1

-- index to stop at after going through "checkAtMost" many items:
local cutoff_index = #result - 2 * check_at_most

-- iterate over the results
while (true_count + false_count + denied_count) < (num_elements * 3) and 1 <= i and i >= cutoff_index do
  local score = tonumber(result[i + 1])
  if score > 0 then
    local element = result[i]
    if string.find(element, "success\\":true") and true_count < num_elements then
      table.insert(true_group, {score, element})
      true_count = true_count + 1
    elseif string.find(element, "success\\":false") and false_count < num_elements then
      table.insert(false_group, {score, element})
      false_count = false_count + 1
    elseif string.find(element, "success\\":\\"denied") and denied_count < num_elements then
      table.insert(denied_group, {score, element})
      denied_count = denied_count + 1
    end
  end
  i = i - 2
end

return {true_group, false_group, denied_group}
`,p=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

return result
`,d=class{redis;prefix;bucketSize;constructor(e){this.redis=e.redis,this.prefix=e.prefix??"@upstash/analytics",this.bucketSize=this.parseWindow(e.window)}validateTableName(e){if(!/^[a-zA-Z0-9_-]+$/.test(e))throw Error(`Invalid table name: ${e}. Table names can only contain letters, numbers, dashes and underscores.`)}parseWindow(e){if("number"==typeof e){if(e<=0)throw Error(`Invalid window: ${e}`);return e}let t=/^(\d+)([smhd])$/;if(!t.test(e))throw Error(`Invalid window: ${e}`);let[,s,n]=e.match(t),i=parseInt(s);switch(n){case"s":return 1e3*i;case"m":return 1e3*i*60;case"h":return 1e3*i*3600;case"d":return 1e3*i*86400;default:throw Error(`Invalid window unit: ${n}`)}}getBucket(e){return Math.floor((e??Date.now())/this.bucketSize)*this.bucketSize}async ingest(e,...t){this.validateTableName(e),await Promise.all(t.map(async t=>{let s=this.getBucket(t.time),n=[this.prefix,e,s].join(":");await this.redis.zincrby(n,1,JSON.stringify({...t,time:void 0}))}))}formatBucketAggregate(e,t,s){let n={};return e.forEach(([e,s])=>{"success"==t&&(e=1===e?"true":null===e?"false":e),n[t]=n[t]||{},n[t][(e??"null").toString()]=s}),{time:s,...n}}async aggregateBucket(e,t,s){this.validateTableName(e);let n=this.getBucket(s),i=[this.prefix,e,n].join(":"),r=await this.redis.eval(h,[i],[t]);return this.formatBucketAggregate(r,t,n)}async aggregateBuckets(e,t,s,n){this.validateTableName(e);let i=this.getBucket(n),r=[];for(let n=0;n<s;n+=1)r.push(this.aggregateBucket(e,t,i)),i-=this.bucketSize;return Promise.all(r)}async aggregateBucketsWithPipeline(e,t,s,n,i){this.validateTableName(e),i=i??48;let r=this.getBucket(n),o=[],a=this.redis.pipeline(),c=[];for(let n=1;n<=s;n+=1){let l=[this.prefix,e,r].join(":");a.eval(h,[l],[t]),o.push(r),r-=this.bucketSize,(n%i==0||n==s)&&(c.push(a.exec()),a=this.redis.pipeline())}return(await Promise.all(c)).flat().map((e,s)=>this.formatBucketAggregate(e,t,o[s]))}async getAllowedBlocked(e,t,s){this.validateTableName(e);let n=[this.prefix,e].join(":"),i=this.getBucket(s),r=await this.redis.eval(p,[n],[i,this.bucketSize,t]),o={};for(let e=0;e<r.length;e+=2){let t=r[e],s=t.identifier,n=+r[e+1];o[s]||(o[s]={success:0,blocked:0}),o[s][t.success?"success":"blocked"]=n}return o}async getMostAllowedBlocked(e,t,s,n,i){this.validateTableName(e);let r=[this.prefix,e].join(":"),o=this.getBucket(n),[a,c,l]=await this.redis.eval(u,[r],[o,this.bucketSize,t,s,i??5*s]);return{allowed:this.toDicts(a),ratelimited:this.toDicts(c),denied:this.toDicts(l)}}toDicts(e){let t=[];for(let s=0;s<e.length;s+=1){let n=+e[s][0],i=e[s][1];t.push({identifier:i.identifier,count:n})}return t}}},90590,(e,t,s)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t)=>{for(var s in t)n(e,s,{get:t[s],enumerable:!0})},c={};a(c,{Analytics:()=>h,IpDenyList:()=>v,MultiRegionRatelimit:()=>C,Ratelimit:()=>I}),t.exports=((e,t,s,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of r(t))o.call(e,c)||c===s||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),c);var l=e.r(38631),h=class{analytics;table="events";constructor(e){this.analytics=new l.Analytics({redis:e.redis,window:"1h",prefix:e.prefix??"@upstash/ratelimit",retention:"90d"})}extractGeo(e){return void 0!==e.geo?e.geo:void 0!==e.cf?e.cf:{}}async record(e){await this.analytics.ingest(this.table,e)}async series(e,t){let s=Math.min((this.analytics.getBucket(Date.now())-this.analytics.getBucket(t))/36e5,256);return this.analytics.aggregateBucketsWithPipeline(this.table,e,s)}async getUsage(e=0){let t=Math.min((this.analytics.getBucket(Date.now())-this.analytics.getBucket(e))/36e5,256);return await this.analytics.getAllowedBlocked(this.table,t)}async getUsageOverTime(e,t){return await this.analytics.aggregateBucketsWithPipeline(this.table,t,e)}async getMostAllowedBlocked(e,t,s){return t=t??5,this.analytics.getMostAllowedBlocked(this.table,e,t,void 0,s)}},u=class{cache;constructor(e){this.cache=e}isBlocked(e){if(!this.cache.has(e))return{blocked:!1,reset:0};let t=this.cache.get(e);return t<Date.now()?(this.cache.delete(e),{blocked:!1,reset:0}):{blocked:!0,reset:t}}blockUntil(e,t){this.cache.set(e,t)}set(e,t){this.cache.set(e,t)}get(e){return this.cache.get(e)||null}incr(e){let t=this.cache.get(e)??0;return t+=1,this.cache.set(e,t),t}pop(e){this.cache.delete(e)}empty(){this.cache.clear()}size(){return this.cache.size}};function p(e){let t=e.match(/^(\d+)\s?(ms|s|m|h|d)$/);if(!t)throw Error(`Unable to parse window size: ${e}`);let s=Number.parseInt(t[1]);switch(t[2]){case"ms":return s;case"s":return 1e3*s;case"m":return 1e3*s*60;case"h":return 1e3*s*3600;case"d":return 1e3*s*86400;default:throw Error(`Unable to parse window size: ${e}`)}}var d=async(e,t,s,n)=>{try{return await e.redis.evalsha(t.hash,s,n)}catch(i){if(`${i}`.includes("NOSCRIPT"))return await e.redis.eval(t.script,s,n);throw i}},m={fixedWindow:{limit:{script:`
  local key           = KEYS[1]
  local window        = ARGV[1]
  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1

  local r = redis.call("INCRBY", key, incrementBy)
  if r == tonumber(incrementBy) then
  -- The first time this key is set, the value will be equal to incrementBy.
  -- So we only need the expire command once
  redis.call("PEXPIRE", key, window)
  end

  return r
`,hash:"b13943e359636db027ad280f1def143f02158c13"},getRemaining:{script:`
      local key = KEYS[1]
      local tokens = 0

      local value = redis.call('GET', key)
      if value then
          tokens = value
      end
      return tokens
    `,hash:"8c4c341934502aee132643ffbe58ead3450e5208"}},slidingWindow:{limit:{script:`
  local currentKey  = KEYS[1]           -- identifier including prefixes
  local previousKey = KEYS[2]           -- key of the previous bucket
  local tokens      = tonumber(ARGV[1]) -- tokens per window
  local now         = ARGV[2]           -- current timestamp in milliseconds
  local window      = ARGV[3]           -- interval in milliseconds
  local incrementBy = ARGV[4]           -- increment rate per request at a given value, default is 1

  local requestsInCurrentWindow = redis.call("GET", currentKey)
  if requestsInCurrentWindow == false then
    requestsInCurrentWindow = 0
  end

  local requestsInPreviousWindow = redis.call("GET", previousKey)
  if requestsInPreviousWindow == false then
    requestsInPreviousWindow = 0
  end
  local percentageInCurrent = ( now % window ) / window
  -- weighted requests to consider from the previous window
  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)
  if requestsInPreviousWindow + requestsInCurrentWindow >= tokens then
    return -1
  end

  local newValue = redis.call("INCRBY", currentKey, incrementBy)
  if newValue == tonumber(incrementBy) then
    -- The first time this key is set, the value will be equal to incrementBy.
    -- So we only need the expire command once
    redis.call("PEXPIRE", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second
  end
  return tokens - ( newValue + requestsInPreviousWindow )
`,hash:"e1391e429b699c780eb0480350cd5b7280fd9213"},getRemaining:{script:`
  local currentKey  = KEYS[1]           -- identifier including prefixes
  local previousKey = KEYS[2]           -- key of the previous bucket
  local now         = ARGV[1]           -- current timestamp in milliseconds
  local window      = ARGV[2]           -- interval in milliseconds

  local requestsInCurrentWindow = redis.call("GET", currentKey)
  if requestsInCurrentWindow == false then
    requestsInCurrentWindow = 0
  end

  local requestsInPreviousWindow = redis.call("GET", previousKey)
  if requestsInPreviousWindow == false then
    requestsInPreviousWindow = 0
  end

  local percentageInCurrent = ( now % window ) / window
  -- weighted requests to consider from the previous window
  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)

  return requestsInPreviousWindow + requestsInCurrentWindow
`,hash:"65a73ac5a05bf9712903bc304b77268980c1c417"}},tokenBucket:{limit:{script:`
  local key         = KEYS[1]           -- identifier including prefixes
  local maxTokens   = tonumber(ARGV[1]) -- maximum number of tokens
  local interval    = tonumber(ARGV[2]) -- size of the window in milliseconds
  local refillRate  = tonumber(ARGV[3]) -- how many tokens are refilled after each interval
  local now         = tonumber(ARGV[4]) -- current timestamp in milliseconds
  local incrementBy = tonumber(ARGV[5]) -- how many tokens to consume, default is 1
        
  local bucket = redis.call("HMGET", key, "refilledAt", "tokens")
        
  local refilledAt
  local tokens

  if bucket[1] == false then
    refilledAt = now
    tokens = maxTokens
  else
    refilledAt = tonumber(bucket[1])
    tokens = tonumber(bucket[2])
  end
        
  if now >= refilledAt + interval then
    local numRefills = math.floor((now - refilledAt) / interval)
    tokens = math.min(maxTokens, tokens + numRefills * refillRate)

    refilledAt = refilledAt + numRefills * interval
  end

  if tokens == 0 then
    return {-1, refilledAt + interval}
  end

  local remaining = tokens - incrementBy
  local expireAt = math.ceil(((maxTokens - remaining) / refillRate)) * interval
        
  redis.call("HSET", key, "refilledAt", refilledAt, "tokens", remaining)
  redis.call("PEXPIRE", key, expireAt)
  return {remaining, refilledAt + interval}
`,hash:"5bece90aeef8189a8cfd28995b479529e270b3c6"},getRemaining:{script:`
  local key         = KEYS[1]
  local maxTokens   = tonumber(ARGV[1])
        
  local bucket = redis.call("HMGET", key, "refilledAt", "tokens")

  if bucket[1] == false then
    return {maxTokens, -1}
  end
        
  return {tonumber(bucket[2]), tonumber(bucket[1])}
`,hash:"a15be2bb1db2a15f7c82db06146f9d08983900d0"}},cachedFixedWindow:{limit:{script:`
  local key     = KEYS[1]
  local window  = ARGV[1]
  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1

  local r = redis.call("INCRBY", key, incrementBy)
  if r == incrementBy then
  -- The first time this key is set, the value will be equal to incrementBy.
  -- So we only need the expire command once
  redis.call("PEXPIRE", key, window)
  end
      
  return r
`,hash:"c26b12703dd137939b9a69a3a9b18e906a2d940f"},getRemaining:{script:`
  local key = KEYS[1]
  local tokens = 0

  local value = redis.call('GET', key)
  if value then
      tokens = value
  end
  return tokens
`,hash:"8e8f222ccae68b595ee6e3f3bf2199629a62b91a"}}},f={fixedWindow:{limit:{script:`
	local key           = KEYS[1]
	local id            = ARGV[1]
	local window        = ARGV[2]
	local incrementBy   = tonumber(ARGV[3])

	redis.call("HSET", key, id, incrementBy)
	local fields = redis.call("HGETALL", key)
	if #fields == 2 and tonumber(fields[2])==incrementBy then
	-- The first time this key is set, and the value will be equal to incrementBy.
	-- So we only need the expire command once
	  redis.call("PEXPIRE", key, window)
	end

	return fields
`,hash:"a8c14f3835aa87bd70e5e2116081b81664abcf5c"},getRemaining:{script:`
      local key = KEYS[1]
      local tokens = 0

      local fields = redis.call("HGETALL", key)

      return fields
    `,hash:"8ab8322d0ed5fe5ac8eb08f0c2e4557f1b4816fd"}},slidingWindow:{limit:{script:`
	local currentKey    = KEYS[1]           -- identifier including prefixes
	local previousKey   = KEYS[2]           -- key of the previous bucket
	local tokens        = tonumber(ARGV[1]) -- tokens per window
	local now           = ARGV[2]           -- current timestamp in milliseconds
	local window        = ARGV[3]           -- interval in milliseconds
	local requestId     = ARGV[4]           -- uuid for this request
	local incrementBy   = tonumber(ARGV[5]) -- custom rate, default is  1

	local currentFields = redis.call("HGETALL", currentKey)
	local requestsInCurrentWindow = 0
	for i = 2, #currentFields, 2 do
	requestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])
	end

	local previousFields = redis.call("HGETALL", previousKey)
	local requestsInPreviousWindow = 0
	for i = 2, #previousFields, 2 do
	requestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])
	end

	local percentageInCurrent = ( now % window) / window
	if requestsInPreviousWindow * (1 - percentageInCurrent ) + requestsInCurrentWindow >= tokens then
	  return {currentFields, previousFields, false}
	end

	redis.call("HSET", currentKey, requestId, incrementBy)

	if requestsInCurrentWindow == 0 then 
	  -- The first time this key is set, the value will be equal to incrementBy.
	  -- So we only need the expire command once
	  redis.call("PEXPIRE", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second
	end
	return {currentFields, previousFields, true}
`,hash:"cb4fdc2575056df7c6d422764df0de3a08d6753b"},getRemaining:{script:`
	local currentKey    = KEYS[1]           -- identifier including prefixes
	local previousKey   = KEYS[2]           -- key of the previous bucket
	local now         	= ARGV[1]           -- current timestamp in milliseconds
  	local window      	= ARGV[2]           -- interval in milliseconds

	local currentFields = redis.call("HGETALL", currentKey)
	local requestsInCurrentWindow = 0
	for i = 2, #currentFields, 2 do
	requestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])
	end

	local previousFields = redis.call("HGETALL", previousKey)
	local requestsInPreviousWindow = 0
	for i = 2, #previousFields, 2 do
	requestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])
	end

	local percentageInCurrent = ( now % window) / window
  	requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)
	
	return requestsInCurrentWindow + requestsInPreviousWindow
`,hash:"558c9306b7ec54abb50747fe0b17e5d44bd24868"}}},w={script:`
      local pattern = KEYS[1]

      -- Initialize cursor to start from 0
      local cursor = "0"

      repeat
          -- Scan for keys matching the pattern
          local scan_result = redis.call('SCAN', cursor, 'MATCH', pattern)

          -- Extract cursor for the next iteration
          cursor = scan_result[1]

          -- Extract keys from the scan result
          local keys = scan_result[2]

          for i=1, #keys do
          redis.call('DEL', keys[i])
          end

      -- Continue scanning until cursor is 0 (end of keyspace)
      until cursor == "0"
    `,hash:"54bd274ddc59fb3be0f42deee2f64322a10e2b50"},g="denyList",y="ipDenyList",x="ipDenyListStatus",b=`
  -- Checks if values provideed in ARGV are present in the deny lists.
  -- This is done using the allDenyListsKey below.

  -- Additionally, checks the status of the ip deny list using the
  -- ipDenyListStatusKey below. Here are the possible states of the
  -- ipDenyListStatusKey key:
  -- * status == -1: set to "disabled" with no TTL
  -- * status == -2: not set, meaning that is was set before but expired
  -- * status  >  0: set to "valid", with a TTL
  --
  -- In the case of status == -2, we set the status to "pending" with
  -- 30 second ttl. During this time, the process which got status == -2
  -- will update the ip deny list.

  local allDenyListsKey     = KEYS[1]
  local ipDenyListStatusKey = KEYS[2]

  local results = redis.call('SMISMEMBER', allDenyListsKey, unpack(ARGV))
  local status  = redis.call('TTL', ipDenyListStatusKey)
  if status == -2 then
    redis.call('SETEX', ipDenyListStatusKey, 30, "pending")
  end

  return { results, status }
`,v={};a(v,{ThresholdError:()=>O,disableIpDenyList:()=>S,updateIpDenyList:()=>R});var O=class extends Error{constructor(e){super(`Allowed threshold values are from 1 to 8, 1 and 8 included. Received: ${e}`),this.name="ThresholdError"}},E=async e=>{if("number"!=typeof e||e<1||e>8)throw new O(e);try{let t=await fetch(`https://raw.githubusercontent.com/stamparm/ipsum/master/levels/${e}.txt`);if(!t.ok)throw Error(`Error fetching data: ${t.statusText}`);return(await t.text()).split("\n").filter(e=>e.length>0)}catch(e){throw Error(`Failed to fetch ip deny list: ${e}`)}},R=async(e,t,s,n)=>{var i;let r=await E(s),o=[t,g,"all"].join(":"),a=[t,g,y].join(":"),c=[t,x].join(":"),l=e.multi();return l.sdiffstore(o,o,a),l.del(a),l.sadd(a,r.at(0),...r.slice(1)),l.sdiffstore(a,a,o),l.sunionstore(o,o,a),l.set(c,"valid",{px:n??864e5-((i||Date.now())-72e5)%864e5}),await l.exec()},S=async(e,t)=>{let s=[t,g,"all"].join(":"),n=[t,g,y].join(":"),i=[t,x].join(":"),r=e.multi();return r.sdiffstore(s,s,n),r.del(n),r.set(i,"disabled"),await r.exec()},k=new u(new Map),T=async(e,t,s)=>{let n,[i,r]=await e.eval(b,[[t,g,"all"].join(":"),[t,x].join(":")],s);return i.map((e,t)=>{if(e){var i;i=s[t],k.size()>1e3&&k.empty(),k.blockUntil(i,Date.now()+6e4),n=s[t]}}),{deniedValue:n,invalidIpDenyList:-2===r}},A=class{limiter;ctx;prefix;timeout;primaryRedis;analytics;enableProtection;denyListThreshold;constructor(e){this.ctx=e.ctx,this.limiter=e.limiter,this.timeout=e.timeout??5e3,this.prefix=e.prefix??"@upstash/ratelimit",this.enableProtection=e.enableProtection??!1,this.denyListThreshold=e.denyListThreshold??6,this.primaryRedis="redis"in this.ctx?this.ctx.redis:this.ctx.regionContexts[0].redis,this.analytics=e.analytics?new h({redis:this.primaryRedis,prefix:this.prefix}):void 0,e.ephemeralCache instanceof Map?this.ctx.cache=new u(e.ephemeralCache):void 0===e.ephemeralCache&&(this.ctx.cache=new u(new Map))}limit=async(e,t)=>{let s=null;try{let n=this.getRatelimitResponse(e,t),{responseArray:i,newTimeoutId:r}=this.applyTimeout(n);s=r;let o=await Promise.race(i);return this.submitAnalytics(o,e,t)}finally{s&&clearTimeout(s)}};blockUntilReady=async(e,t)=>{let s;if(t<=0)throw Error("timeout must be positive");let n=Date.now()+t;for(;!(s=await this.limit(e)).success;){if(0===s.reset)throw Error("This should not happen");let e=Math.min(s.reset,n)-Date.now();if(await new Promise(t=>setTimeout(t,e)),Date.now()>n)break}return s};resetUsedTokens=async e=>{let t=[this.prefix,e].join(":");await this.limiter().resetTokens(this.ctx,t)};getRemaining=async e=>{let t=[this.prefix,e].join(":");return await this.limiter().getRemaining(this.ctx,t)};getRatelimitResponse=async(e,t)=>{let s=this.getKey(e),n=this.getDefinedMembers(e,t),i=n.find(e=>k.isBlocked(e).blocked),r=i?[{success:!1,limit:0,remaining:0,reset:0,pending:Promise.resolve(),reason:"denyList",deniedValue:i},{deniedValue:i,invalidIpDenyList:!1}]:await Promise.all([this.limiter().limit(this.ctx,s,t?.rate),this.enableProtection?T(this.primaryRedis,this.prefix,n):{deniedValue:void 0,invalidIpDenyList:!1}]);return((e,t,[s,n],i)=>{if(n.deniedValue&&(s.success=!1,s.remaining=0,s.reason="denyList",s.deniedValue=n.deniedValue),n.invalidIpDenyList){let n=R(e,t,i);s.pending=Promise.all([s.pending,n])}return s})(this.primaryRedis,this.prefix,r,this.denyListThreshold)};applyTimeout=e=>{let t=null,s=[e];if(this.timeout>0){let e=new Promise(e=>{t=setTimeout(()=>{e({success:!0,limit:0,remaining:0,reset:0,pending:Promise.resolve(),reason:"timeout"})},this.timeout)});s.push(e)}return{responseArray:s,newTimeoutId:t}};submitAnalytics=(e,t,s)=>{if(this.analytics)try{let n=s?this.analytics.extractGeo(s):void 0,i=this.analytics.record({identifier:"denyList"===e.reason?e.deniedValue:t,time:Date.now(),success:"denyList"===e.reason?"denied":e.success,...n}).catch(e=>{let t="Failed to record analytics";`${e}`.includes("WRONGTYPE")&&(t=`
    Failed to record analytics. See the information below:

    This can occur when you uprade to Ratelimit version 1.1.2
    or later from an earlier version.

    This occurs simply because the way we store analytics data
    has changed. To avoid getting this error, disable analytics
    for *an hour*, then simply enable it back.

    `),console.warn(t,e)});e.pending=Promise.all([e.pending,i])}catch(e){console.warn("Failed to record analytics",e)}return e};getKey=e=>[this.prefix,e].join(":");getDefinedMembers=(e,t)=>[e,t?.ip,t?.userAgent,t?.country].filter(Boolean)};function _(){let e="",t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",s=t.length;for(let n=0;n<16;n++)e+=t.charAt(Math.floor(Math.random()*s));return e}var C=class extends A{constructor(e){super({prefix:e.prefix,limiter:e.limiter,timeout:e.timeout,analytics:e.analytics,ctx:{regionContexts:e.redis.map(e=>({redis:e})),cache:e.ephemeralCache?new u(e.ephemeralCache):void 0}})}static fixedWindow(e,t){let s=p(t);return()=>({async limit(t,n,i){if(t.cache){let{blocked:s,reset:i}=t.cache.isBlocked(n);if(s)return{success:!1,limit:e,remaining:0,reset:i,pending:Promise.resolve(),reason:"cacheBlock"}}let r=_(),o=Math.floor(Date.now()/s),a=[n,o].join(":"),c=i?Math.max(1,i):1,l=t.regionContexts.map(e=>({redis:e.redis,request:d(e,f.fixedWindow.limit,[a],[r,s,c])})),h=e-(await Promise.any(l.map(e=>e.request))).reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0);async function u(){let t=[...new Set((await Promise.all(l.map(e=>e.request))).flat().reduce((e,t,s)=>(s%2==0&&e.push(t),e),[])).values()];for(let s of l){let n=(await s.request).reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0),i=(await s.request).reduce((e,t,s)=>(s%2==0&&e.push(t),e),[]);if(n>=e)continue;let r=t.filter(e=>!i.includes(e));if(0!==r.length)for(let e of r)await s.redis.hset(a,{[e]:c})}}let p=h>0,m=(o+1)*s;return t.cache&&!p&&t.cache.blockUntil(n,m),{success:p,limit:e,remaining:h,reset:m,pending:u()}},async getRemaining(t,n){let i=Math.floor(Date.now()/s),r=[n,i].join(":"),o=t.regionContexts.map(e=>({redis:e.redis,request:d(e,f.fixedWindow.getRemaining,[r],[null])}));return{remaining:Math.max(0,e-(await Promise.any(o.map(e=>e.request))).reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0)),reset:(i+1)*s}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await Promise.all(e.regionContexts.map(e=>{d(e,w,[s],[null])}))}})}static slidingWindow(e,t){let s=p(t),n=p(t);return()=>({async limit(t,i,r){if(t.cache){let{blocked:s,reset:n}=t.cache.isBlocked(i);if(s)return{success:!1,limit:e,remaining:0,reset:n,pending:Promise.resolve(),reason:"cacheBlock"}}let o=_(),a=Date.now(),c=Math.floor(a/s),l=[i,c].join(":"),h=[i,c-1].join(":"),u=r?Math.max(1,r):1,p=t.regionContexts.map(t=>({redis:t.redis,request:d(t,f.slidingWindow.limit,[l,h],[e,a,n,o,u])})),m=a%n/n,[w,g,y]=await Promise.any(p.map(e=>e.request));y&&w.push(o,u.toString());let x=e-(Math.ceil(g.reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0)*(1-m))+w.reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0));async function b(){let t=[...new Set((await Promise.all(p.map(e=>e.request))).flatMap(([e])=>e).reduce((e,t,s)=>(s%2==0&&e.push(t),e),[])).values()];for(let s of p){let[n,i,r]=await s.request,o=n.reduce((e,t,s)=>(s%2==0&&e.push(t),e),[]);if(n.reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0)>=e)continue;let a=t.filter(e=>!o.includes(e));if(0!==a.length)for(let e of a)await s.redis.hset(l,{[e]:u})}}let v=(c+1)*n;return t.cache&&!y&&t.cache.blockUntil(i,v),{success:!!y,limit:e,remaining:Math.max(0,x),reset:v,pending:b()}},async getRemaining(t,n){let i=Date.now(),r=Math.floor(i/s),o=[n,r].join(":"),a=[n,r-1].join(":"),c=t.regionContexts.map(e=>({redis:e.redis,request:d(e,f.slidingWindow.getRemaining,[o,a],[i,s])}));return{remaining:Math.max(0,e-await Promise.any(c.map(e=>e.request))),reset:(r+1)*s}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await Promise.all(e.regionContexts.map(e=>{d(e,w,[s],[null])}))}})}},I=class extends A{constructor(e){super({prefix:e.prefix,limiter:e.limiter,timeout:e.timeout,analytics:e.analytics,ctx:{redis:e.redis},ephemeralCache:e.ephemeralCache,enableProtection:e.enableProtection,denyListThreshold:e.denyListThreshold})}static fixedWindow(e,t){let s=p(t);return()=>({async limit(t,n,i){let r=Math.floor(Date.now()/s),o=[n,r].join(":");if(t.cache){let{blocked:s,reset:i}=t.cache.isBlocked(n);if(s)return{success:!1,limit:e,remaining:0,reset:i,pending:Promise.resolve(),reason:"cacheBlock"}}let a=i?Math.max(1,i):1,c=await d(t,m.fixedWindow.limit,[o],[s,a]),l=c<=e,h=Math.max(0,e-c),u=(r+1)*s;return t.cache&&!l&&t.cache.blockUntil(n,u),{success:l,limit:e,remaining:h,reset:u,pending:Promise.resolve()}},async getRemaining(t,n){let i=Math.floor(Date.now()/s),r=[n,i].join(":");return{remaining:Math.max(0,e-await d(t,m.fixedWindow.getRemaining,[r],[null])),reset:(i+1)*s}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await d(e,w,[s],[null])}})}static slidingWindow(e,t){let s=p(t);return()=>({async limit(t,n,i){let r=Date.now(),o=Math.floor(r/s),a=[n,o].join(":"),c=[n,o-1].join(":");if(t.cache){let{blocked:s,reset:i}=t.cache.isBlocked(n);if(s)return{success:!1,limit:e,remaining:0,reset:i,pending:Promise.resolve(),reason:"cacheBlock"}}let l=i?Math.max(1,i):1,h=await d(t,m.slidingWindow.limit,[a,c],[e,r,s,l]),u=h>=0,p=(o+1)*s;return t.cache&&!u&&t.cache.blockUntil(n,p),{success:u,limit:e,remaining:Math.max(0,h),reset:p,pending:Promise.resolve()}},async getRemaining(t,n){let i=Date.now(),r=Math.floor(i/s),o=[n,r].join(":"),a=[n,r-1].join(":");return{remaining:Math.max(0,e-await d(t,m.slidingWindow.getRemaining,[o,a],[i,s])),reset:(r+1)*s}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await d(e,w,[s],[null])}})}static tokenBucket(e,t,s){let n=p(t);return()=>({async limit(t,i,r){if(t.cache){let{blocked:e,reset:n}=t.cache.isBlocked(i);if(e)return{success:!1,limit:s,remaining:0,reset:n,pending:Promise.resolve(),reason:"cacheBlock"}}let o=Date.now(),a=r?Math.max(1,r):1,[c,l]=await d(t,m.tokenBucket.limit,[i],[s,n,e,o,a]),h=c>=0;return t.cache&&!h&&t.cache.blockUntil(i,l),{success:h,limit:s,remaining:c,reset:l,pending:Promise.resolve()}},async getRemaining(e,t){let[i,r]=await d(e,m.tokenBucket.getRemaining,[t],[s]),o=Date.now()+n,a=r+n;return{remaining:i,reset:-1===r?o:a}},async resetTokens(e,t){e.cache&&e.cache.pop(t),await d(e,w,[t],[null])}})}static cachedFixedWindow(e,t){let s=p(t);return()=>({async limit(t,n,i){if(!t.cache)throw Error("This algorithm requires a cache");let r=Math.floor(Date.now()/s),o=[n,r].join(":"),a=(r+1)*s,c=i?Math.max(1,i):1;if("number"==typeof t.cache.get(o)){let n=t.cache.incr(o),i=n<e,r=i?d(t,m.cachedFixedWindow.limit,[o],[s,c]):Promise.resolve();return{success:i,limit:e,remaining:e-n,reset:a,pending:r}}let l=await d(t,m.cachedFixedWindow.limit,[o],[s,c]);t.cache.set(o,l);let h=e-l;return{success:h>=0,limit:e,remaining:h,reset:a,pending:Promise.resolve()}},async getRemaining(t,n){if(!t.cache)throw Error("This algorithm requires a cache");let i=Math.floor(Date.now()/s),r=[n,i].join(":");return"number"==typeof t.cache.get(r)?{remaining:Math.max(0,e-(t.cache.get(r)??0)),reset:(i+1)*s}:{remaining:Math.max(0,e-await d(t,m.cachedFixedWindow.getRemaining,[r],[null])),reset:(i+1)*s}},async resetTokens(e,t){if(!e.cache)throw Error("This algorithm requires a cache");let n=[t,Math.floor(Date.now()/s)].join(":");e.cache.pop(n);let i=[t,"*"].join(":");await d(e,w,[i],[null])}})}}},66680,(e,t,s)=>{t.exports=e.x("node:crypto",()=>require("node:crypto"))},31329,e=>{"use strict";let t,s,n;var i,r,o,a,c,l,h,u,p,d,m,f,w,g,y,x,b,v,O,E,R,S,k,T,A,_,C,I,P,N,M,D,L,U,j=e.i(23811),$=e.i(84077),z=e.i(21829),W=e.i(82598),q=e.i(35696),B=e.i(36758),K=e.i(81564),F=e.i(40726),G=e.i(4437),H=e.i(34720),V=e.i(70539),J=e.i(30867),Y=e.i(55273),X=e.i(76945),Z=e.i(95556),Q=e.i(22719),ee=e.i(93695);e.i(11977);var et=e.i(36363),es=e.i(30192);function en(e,t,s,n,i){if("m"===n)throw TypeError("Private method is not writable");if("a"===n&&!i)throw TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!i:!t.has(e))throw TypeError("Cannot write private member to an object whose class did not declare it");return"a"===n?i.call(e,s):i?i.value=s:t.set(e,s),s}function ei(e,t,s,n){if("a"===s&&!n)throw TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?n:"a"===s?n.call(e):n?n.value:t.get(e)}let er=function(){let{crypto:e}=globalThis;if(e?.randomUUID)return er=e.randomUUID.bind(e),e.randomUUID();let t=new Uint8Array(1),s=e?()=>e.getRandomValues(t)[0]:()=>255*Math.random()&255;return"10000000-1000-4000-8000-100000000000".replace(/[018]/g,e=>(e^s()&15>>e/4).toString(16))};function eo(e){return"object"==typeof e&&null!==e&&("name"in e&&"AbortError"===e.name||"message"in e&&String(e.message).includes("FetchRequestCanceledException"))}let ea=e=>{if(e instanceof Error)return e;if("object"==typeof e&&null!==e){try{if("[object Error]"===Object.prototype.toString.call(e)){let t=Error(e.message,e.cause?{cause:e.cause}:{});return e.stack&&(t.stack=e.stack),e.cause&&!t.cause&&(t.cause=e.cause),e.name&&(t.name=e.name),t}}catch{}try{return Error(JSON.stringify(e))}catch{}}return Error(e)};class ec extends Error{}class el extends ec{constructor(e,t,s,n){super(`${el.makeMessage(e,t,s)}`),this.status=e,this.headers=n,this.error=t}static makeMessage(e,t,s){let n=t?.message?"string"==typeof t.message?t.message:JSON.stringify(t.message):t?JSON.stringify(t):s;return e&&n?`${e} ${n}`:e?`${e} status code (no body)`:n||"(no status code or body)"}static generate(e,t,s,n){return e&&n?400===e?new ed(e,t,s,n):401===e?new em(e,t,s,n):403===e?new ef(e,t,s,n):404===e?new ew(e,t,s,n):409===e?new eg(e,t,s,n):422===e?new ey(e,t,s,n):429===e?new ex(e,t,s,n):e>=500?new eb(e,t,s,n):new el(e,t,s,n):new eu({message:s,cause:ea(t)})}}class eh extends el{constructor({message:e}={}){super(void 0,void 0,e||"Request was aborted.",void 0)}}class eu extends el{constructor({message:e,cause:t}){super(void 0,void 0,e||"Connection error.",void 0),t&&(this.cause=t)}}class ep extends eu{constructor({message:e}={}){super({message:e??"Request timed out."})}}class ed extends el{}class em extends el{}class ef extends el{}class ew extends el{}class eg extends el{}class ey extends el{}class ex extends el{}class eb extends el{}let ev=/^[a-z][a-z0-9+.-]*:/i,eO=e=>(eO=Array.isArray)(e),eE=eO,eR="0.22.0",eS=e=>"x32"===e?"x32":"x86_64"===e||"x64"===e?"x64":"arm"===e?"arm":"aarch64"===e||"arm64"===e?"arm64":e?`other:${e}`:"unknown",ek=e=>(e=e.toLowerCase()).includes("ios")?"iOS":"android"===e?"Android":"darwin"===e?"MacOS":"win32"===e?"Windows":"freebsd"===e?"FreeBSD":"openbsd"===e?"OpenBSD":"linux"===e?"Linux":e?`Other:${e}`:"Unknown";function eT(...e){let t=globalThis.ReadableStream;if(void 0===t)throw Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");return new t(...e)}function eA(e){let t=Symbol.asyncIterator in e?e[Symbol.asyncIterator]():e[Symbol.iterator]();return eT({start(){},async pull(e){let{done:s,value:n}=await t.next();s?e.close():e.enqueue(n)},async cancel(){await t.return?.()}})}function e_(e){if(e[Symbol.asyncIterator])return e;let t=e.getReader();return{async next(){try{let e=await t.read();return e?.done&&t.releaseLock(),e}catch(e){throw t.releaseLock(),e}},async return(){let e=t.cancel();return t.releaseLock(),await e,{done:!0,value:void 0}},[Symbol.asyncIterator](){return this}}}async function eC(e){if(null===e||"object"!=typeof e)return;if(e[Symbol.asyncIterator])return void await e[Symbol.asyncIterator]().return?.();let t=e.getReader(),s=t.cancel();t.releaseLock(),await s}let eI=({headers:e,body:t})=>({bodyHeaders:{"content-type":"application/json"},body:JSON.stringify(t)}),eP=()=>{if("undefined"==typeof File){let{process:e}=globalThis;throw Error("`File` is not defined as a global, which is required for file uploads."+("string"==typeof e?.versions?.node&&20>parseInt(e.versions.node.split("."))?" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.":""))}};function eN(e,t,s){return eP(),new File(e,t??"unknown_file",s)}function eM(e){return("object"==typeof e&&null!==e&&("name"in e&&e.name&&String(e.name)||"url"in e&&e.url&&String(e.url)||"filename"in e&&e.filename&&String(e.filename)||"path"in e&&e.path&&String(e.path))||"").split(/[\\/]/).pop()||void 0}let eD=e=>null!=e&&"object"==typeof e&&"function"==typeof e[Symbol.asyncIterator],eL=async(e,t)=>({...e,body:await ej(e.body,t)}),eU=new WeakMap,ej=async(e,t)=>{if(!await function(e){let t="function"==typeof e?e:e.fetch,s=eU.get(t);if(s)return s;let n=(async()=>{try{let e="Response"in t?t.Response:(await t("data:,")).constructor,s=new FormData;if(s.toString()===await new e(s).text())return!1;return!0}catch{return!0}})();return eU.set(t,n),n}(t))throw TypeError("The provided fetch function does not support file uploads with the current global FormData class.");let s=new FormData;return await Promise.all(Object.entries(e||{}).map(([e,t])=>eW(s,e,t))),s},e$=e=>e instanceof Blob&&"name"in e,ez=e=>{if("object"==typeof e&&null!==e&&(e instanceof Response||eD(e)||e$(e)))return!0;if(Array.isArray(e))return e.some(ez);if(e&&"object"==typeof e){for(let t in e)if(ez(e[t]))return!0}return!1},eW=async(e,t,s)=>{if(void 0!==s){if(null==s)throw TypeError(`Received null for "${t}"; to pass null in FormData, you must use the string 'null'`);if("string"==typeof s||"number"==typeof s||"boolean"==typeof s)e.append(t,String(s));else if(s instanceof Response)e.append(t,eN([await s.blob()],eM(s)));else if(eD(s))e.append(t,eN([await new Response(eA(s)).blob()],eM(s)));else if(e$(s))e.append(t,s,eM(s));else if(Array.isArray(s))await Promise.all(s.map(s=>eW(e,t+"[]",s)));else if("object"==typeof s)await Promise.all(Object.entries(s).map(([s,n])=>eW(e,`${t}[${s}]`,n)));else throw TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${s} instead`)}},eq=e=>null!=e&&"object"==typeof e&&"number"==typeof e.size&&"string"==typeof e.type&&"function"==typeof e.text&&"function"==typeof e.slice&&"function"==typeof e.arrayBuffer;async function eB(e,t,s){let n,i;if(eP(),null!=(n=e=await e)&&"object"==typeof n&&"string"==typeof n.name&&"number"==typeof n.lastModified&&eq(n))return e instanceof File?e:eN([await e.arrayBuffer()],e.name);if(null!=(i=e)&&"object"==typeof i&&"string"==typeof i.url&&"function"==typeof i.blob){let n=await e.blob();return t||(t=new URL(e.url).pathname.split(/[\\/]/).pop()),eN(await eK(n),t,s)}let r=await eK(e);if(t||(t=eM(e)),!s?.type){let e=r.find(e=>"object"==typeof e&&"type"in e&&e.type);"string"==typeof e&&(s={...s,type:e})}return eN(r,t,s)}async function eK(e){let t=[];if("string"==typeof e||ArrayBuffer.isView(e)||e instanceof ArrayBuffer)t.push(e);else if(eq(e))t.push(e instanceof Blob?e:await e.arrayBuffer());else if(eD(e))for await(let s of e)t.push(...await eK(s));else{let t=e?.constructor?.name;throw Error(`Unexpected data type: ${typeof e}${t?`; constructor: ${t}`:""}${function(e){if("object"!=typeof e||null===e)return"";let t=Object.getOwnPropertyNames(e);return`; props: [${t.map(e=>`"${e}"`).join(", ")}]`}(e)}`)}return t}class eF{constructor(e){this._client=e}}class eG extends eF{create(e,t){return this._client.post("/audio/transcriptions",eL({body:e,...t},this._client))}}class eH extends eF{create(e,t){return this._client.post("/audio/translations",eL({body:e,...t},this._client))}}let eV=Symbol("brand.privateNullableHeaders"),eJ=e=>{let t=new Headers,s=new Set;for(let n of e){let e=new Set;for(let[i,r]of function*(e){let t;if(!e)return;if(eV in e){let{values:t,nulls:s}=e;for(let e of(yield*t.entries(),s))yield[e,null];return}let s=!1;for(let n of(e instanceof Headers?t=e.entries():eE(e)?t=e:(s=!0,t=Object.entries(e??{})),t)){let e=n[0];if("string"!=typeof e)throw TypeError("expected header name to be a string");let t=eE(n[1])?n[1]:[n[1]],i=!1;for(let n of t)void 0!==n&&(s&&!i&&(i=!0,yield[e,null]),yield[e,n])}}(n)){let n=i.toLowerCase();e.has(n)||(t.delete(i),e.add(n)),null===r?(t.delete(i),s.add(n)):(t.append(i,r),s.delete(n))}}return{[eV]:!0,values:t,nulls:s}};class eY extends eF{constructor(){super(...arguments),this.transcriptions=new eG(this._client),this.translations=new eH(this._client)}create(e,t){return this._client.post("/audio/speech",{body:e,...t,headers:eJ([{Accept:"application/octet-stream"},t?.headers]),stream:e.stream??!1,__binaryResponse:!0})}}function eX(e){return e.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g,encodeURIComponent)}eY.Transcriptions=eG,eY.Translations=eH;let eZ=Object.freeze(Object.create(null)),eQ=((e=eX)=>function(t,...s){let n;if(1===t.length)return t[0];let i=!1,r=[],o=t.reduce((t,n,o)=>{/[?#]/.test(n)&&(i=!0);let a=s[o],c=(i?encodeURIComponent:e)(""+a);return o!==s.length&&(null==a||"object"==typeof a&&a.toString===Object.getPrototypeOf(Object.getPrototypeOf(a.hasOwnProperty??eZ)??eZ)?.toString)&&(c=a+"",r.push({start:t.length+n.length,length:c.length,error:`Value of type ${Object.prototype.toString.call(a).slice(8,-1)} is not a valid path parameter`})),t+n+(o===s.length?"":c)},""),a=o.split(/[?#]/,1)[0],c=/(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;for(;null!==(n=c.exec(a));)r.push({start:n.index,length:n[0].length,error:`Value "${n[0]}" can't be safely passed as a path parameter`});if(r.sort((e,t)=>e.start-t.start),r.length>0){let e=0,t=r.reduce((t,s)=>{let n=" ".repeat(s.start-e),i="^".repeat(s.length);return e=s.start+s.length,t+n+i},"");throw new ec(`Path parameters result in path with invalid segments:
${r.map(e=>e.error).join("\n")}
${o}
${t}`)}return o})(eX);class e0 extends eF{create(e,t){return this._client.post("/batches",{body:e,...t})}retrieve(e,t){return this._client.get(eQ`/batches/${e}`,t)}list(e){return this._client.get("/batches",e)}}function e1(e){return"function"==typeof e.parse}let e2=e=>e?.role==="assistant",e3=e=>e?.role==="function",e4=e=>e?.role==="tool";class e5{constructor(){i.add(this),this.controller=new AbortController,r.set(this,void 0),o.set(this,()=>{}),a.set(this,()=>{}),c.set(this,void 0),l.set(this,()=>{}),h.set(this,()=>{}),u.set(this,{}),this._chatCompletions=[],this.messages=[],p.set(this,!1),d.set(this,!1),m.set(this,!1),f.set(this,!1),v.set(this,e=>{if(en(this,d,!0,"f"),e instanceof Error&&"AbortError"===e.name&&(e=new eh),e instanceof eh)return en(this,m,!0,"f"),this._emit("abort",e);if(e instanceof ec)return this._emit("error",e);if(e instanceof Error){let t=new t(e.message);return t.cause=e,this._emit("error",t)}return this._emit("error",new ec(String(e)))}),en(this,r,new Promise((e,t)=>{en(this,o,e,"f"),en(this,a,t,"f")}),"f"),en(this,c,new Promise((e,t)=>{en(this,l,e,"f"),en(this,h,t,"f")}),"f"),ei(this,r,"f").catch(()=>{}),ei(this,c,"f").catch(()=>{})}_run(e){setTimeout(()=>{e().then(()=>{this._emitFinal(),this._emit("end")},ei(this,v,"f"))},0)}_addChatCompletion(e){this._chatCompletions.push(e),this._emit("chatCompletion",e);let t=e.choices[0]?.message;return t&&this._addMessage(t),e}_addMessage(e,t=!0){if("content"in e||(e.content=null),this.messages.push(e),t){if(this._emit("message",e),(e3(e)||e4(e))&&e.content)this._emit("functionCallResult",e.content);else if(e2(e)&&e.function_call)this._emit("functionCall",e.function_call);else if(e2(e)&&e.tool_calls)for(let t of e.tool_calls)"function"===t.type&&this._emit("functionCall",t.function)}}_connected(){this.ended||(ei(this,o,"f").call(this),this._emit("connect"))}get ended(){return ei(this,p,"f")}get errored(){return ei(this,d,"f")}get aborted(){return ei(this,m,"f")}abort(){this.controller.abort()}on(e,t){return(ei(this,u,"f")[e]||(ei(this,u,"f")[e]=[])).push({listener:t}),this}off(e,t){let s=ei(this,u,"f")[e];if(!s)return this;let n=s.findIndex(e=>e.listener===t);return n>=0&&s.splice(n,1),this}once(e,t){return(ei(this,u,"f")[e]||(ei(this,u,"f")[e]=[])).push({listener:t,once:!0}),this}emitted(e){return new Promise((t,s)=>{en(this,f,!0,"f"),"error"!==e&&this.once("error",s),this.once(e,t)})}async done(){en(this,f,!0,"f"),await ei(this,c,"f")}async finalChatCompletion(){await this.done();let e=this._chatCompletions[this._chatCompletions.length-1];if(!e)throw new ec("stream ended without producing a ChatCompletion");return e}async finalContent(){return await this.done(),ei(this,i,"m",w).call(this)}async finalMessage(){return await this.done(),ei(this,i,"m",g).call(this)}async finalFunctionCall(){return await this.done(),ei(this,i,"m",y).call(this)}async finalFunctionCallResult(){return await this.done(),ei(this,i,"m",x).call(this)}async totalUsage(){return await this.done(),ei(this,i,"m",b).call(this)}allChatCompletions(){return[...this._chatCompletions]}_emit(e,...t){if(ei(this,p,"f"))return;"end"===e&&(en(this,p,!0,"f"),ei(this,l,"f").call(this));let s=ei(this,u,"f")[e];if(s&&(ei(this,u,"f")[e]=s.filter(e=>!e.once),s.forEach(({listener:e})=>e(...t))),"abort"===e){let e=t[0];ei(this,f,"f")||s?.length||Promise.reject(e),ei(this,a,"f").call(this,e),ei(this,h,"f").call(this,e),this._emit("end");return}if("error"===e){let e=t[0];ei(this,f,"f")||s?.length||Promise.reject(e),ei(this,a,"f").call(this,e),ei(this,h,"f").call(this,e),this._emit("end")}}_emitFinal(){let e=this._chatCompletions[this._chatCompletions.length-1];e&&this._emit("finalChatCompletion",e);let t=ei(this,i,"m",g).call(this);t&&this._emit("finalMessage",t);let s=ei(this,i,"m",w).call(this);s&&this._emit("finalContent",s);let n=ei(this,i,"m",y).call(this);n&&this._emit("finalFunctionCall",n);let r=ei(this,i,"m",x).call(this);null!=r&&this._emit("finalFunctionCallResult",r),this._chatCompletions.some(e=>e.usage)&&this._emit("totalUsage",ei(this,i,"m",b).call(this))}async _createChatCompletion(e,t,s){let n=s?.signal;n&&(n.aborted&&this.controller.abort(),n.addEventListener("abort",()=>this.controller.abort())),ei(this,i,"m",O).call(this,t);let r=await e.create({...t,stream:!1},{...s,signal:this.controller.signal});return this._connected(),this._addChatCompletion(r)}async _runChatCompletion(e,t,s){for(let e of t.messages)this._addMessage(e,!1);return await this._createChatCompletion(e,t,s)}async _runFunctions(e,t,s){let n="function",{function_call:r="auto",stream:o,...a}=t,c="string"!=typeof r&&r?.name,{maxChatCompletions:l=10}=s||{},h={};for(let e of t.functions)h[e.name||e.function.name]=e;let u=t.functions.map(e=>({name:e.name||e.function.name,parameters:e.parameters,description:e.description}));for(let e of t.messages)this._addMessage(e,!1);for(let t=0;t<l;++t){let t,o=await this._createChatCompletion(e,{...a,function_call:r,functions:u,messages:[...this.messages]},s),l=o.choices[0]?.message;if(!l)throw new ec("missing message in ChatCompletion response");if(!l.function_call)return;let{name:p,arguments:d}=l.function_call,m=h[p];if(m){if(c&&c!==p){let e=`Invalid function_call: ${JSON.stringify(p)}. ${JSON.stringify(c)} requested. Please try again`;this._addMessage({role:n,name:p,content:e});continue}}else{let e=`Invalid function_call: ${JSON.stringify(p)}. Available options are: ${u.map(e=>JSON.stringify(e.name)).join(", ")}. Please try again`;this._addMessage({role:n,name:p,content:e});continue}try{t=e1(m)?await m.parse(d):d}catch(e){this._addMessage({role:n,name:p,content:e instanceof Error?e.message:String(e)});continue}let f=await m.function(t,this),w=ei(this,i,"m",E).call(this,f);if(this._addMessage({role:n,name:p,content:w}),c)return}}async _runTools(e,t,s){let n="tool",{tool_choice:r="auto",stream:o,...a}=t,c="string"!=typeof r&&r?.function?.name,{maxChatCompletions:l=10}=s||{},h={};for(let e of t.tools)"function"===e.type&&(h[e.function.name||e.function.function.name]=e.function);let u="tools"in t?t.tools.map(e=>"function"===e.type?{type:"function",function:{name:e.function.name||e.function.function.name,parameters:e.function.parameters,description:e.function.description}}:e):void 0;for(let e of t.messages)this._addMessage(e,!1);for(let t=0;t<l;++t){let t=await this._createChatCompletion(e,{...a,tool_choice:r,tools:u,messages:[...this.messages]},s),o=t.choices[0]?.message;if(!o)throw new ec("missing message in ChatCompletion response");if(!o.tool_calls)break;for(let e of o.tool_calls){let t;if("function"!==e.type)continue;let s=e.id,{name:r,arguments:o}=e.function,a=h[r];if(a){if(c&&c!==r){let e=`Invalid tool_call: ${JSON.stringify(r)}. ${JSON.stringify(c)} requested. Please try again`;this._addMessage({role:n,tool_call_id:s,content:e});continue}}else{let e=`Invalid tool_call: ${JSON.stringify(r)}. Available options are: ${u.map(e=>JSON.stringify(e.function.name)).join(", ")}. Please try again`;this._addMessage({role:n,tool_call_id:s,content:e});continue}try{t=e1(a)?await a.parse(o):o}catch(t){let e=t instanceof Error?t.message:String(t);this._addMessage({role:n,tool_call_id:s,content:e});continue}let l=await a.function(t,this),p=ei(this,i,"m",E).call(this,l);if(this._addMessage({role:n,tool_call_id:s,content:p}),c)return}}}}function e6(e){let t;return(s??(s=(t=new globalThis.TextEncoder).encode.bind(t)))(e)}function e8(e){let t;return(n??(n=(t=new globalThis.TextDecoder).decode.bind(t)))(e)}r=new WeakMap,o=new WeakMap,a=new WeakMap,c=new WeakMap,l=new WeakMap,h=new WeakMap,u=new WeakMap,p=new WeakMap,d=new WeakMap,m=new WeakMap,f=new WeakMap,v=new WeakMap,i=new WeakSet,w=function(){return ei(this,i,"m",g).call(this).content??null},g=function(){let e=this.messages.length;for(;e-- >0;){let t=this.messages[e];if(e2(t))return{...t,content:t.content??null}}throw new ec("stream ended without producing a ChatCompletionMessage with role=assistant")},y=function(){for(let e=this.messages.length-1;e>=0;e--){let t=this.messages[e];if(e2(t)&&t?.function_call)return t.function_call;if(e2(t)&&t?.tool_calls?.length)return t.tool_calls.at(-1)?.function}},x=function(){for(let e=this.messages.length-1;e>=0;e--){let t=this.messages[e];if(e3(t)&&null!=t.content||e4(t)&&null!=t.content&&this.messages.some(e=>"assistant"===e.role&&e.tool_calls?.some(e=>"function"===e.type&&e.id===t.tool_call_id)))return t.content}},b=function(){let e={completion_tokens:0,prompt_tokens:0,total_tokens:0};for(let{usage:t}of this._chatCompletions)t&&(e.completion_tokens+=t.completion_tokens,e.prompt_tokens+=t.prompt_tokens,e.total_tokens+=t.total_tokens);return e},O=function(e){if(null!=e.n&&e.n>1)throw new ec("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.")},E=function(e){return"string"==typeof e?e:void 0===e?"undefined":JSON.stringify(e)};class e9{constructor(){R.set(this,void 0),S.set(this,void 0),en(this,R,new Uint8Array,"f"),en(this,S,null,"f")}decode(e){let t;if(null==e)return[];let s=e instanceof ArrayBuffer?new Uint8Array(e):"string"==typeof e?e6(e):e;en(this,R,function(e){let t=0;for(let s of e)t+=s.length;let s=new Uint8Array(t),n=0;for(let t of e)s.set(t,n),n+=t.length;return s}([ei(this,R,"f"),s]),"f");let n=[];for(;null!=(t=function(e,t){for(let s=t??0;s<e.length;s++){if(10===e[s])return{preceding:s,index:s+1,carriage:!1};if(13===e[s])return{preceding:s,index:s+1,carriage:!0}}return null}(ei(this,R,"f"),ei(this,S,"f")));){if(t.carriage&&null==ei(this,S,"f")){en(this,S,t.index,"f");continue}if(null!=ei(this,S,"f")&&(t.index!==ei(this,S,"f")+1||t.carriage)){n.push(e8(ei(this,R,"f").subarray(0,ei(this,S,"f")-1))),en(this,R,ei(this,R,"f").subarray(ei(this,S,"f")),"f"),en(this,S,null,"f");continue}let e=null!==ei(this,S,"f")?t.preceding-1:t.preceding,s=e8(ei(this,R,"f").subarray(0,e));n.push(s),en(this,R,ei(this,R,"f").subarray(t.index),"f"),en(this,S,null,"f")}return n}flush(){return ei(this,R,"f").length?this.decode("\n"):[]}}R=new WeakMap,S=new WeakMap,e9.NEWLINE_CHARS=new Set(["\n","\r"]),e9.NEWLINE_REGEXP=/\r\n|[\n\r]/g;let e7={off:0,error:200,warn:300,info:400,debug:500},te=(e,t,s)=>{if(e){if(Object.prototype.hasOwnProperty.call(e7,e))return e;tr(s).warn(`${t} was set to ${JSON.stringify(e)}, expected one of ${JSON.stringify(Object.keys(e7))}`)}};function tt(){}function ts(e,t,s){return!t||e7[e]>e7[s]?tt:t[e].bind(t)}let tn={error:tt,warn:tt,info:tt,debug:tt},ti=new WeakMap;function tr(e){let t=e.logger,s=e.logLevel??"off";if(!t)return tn;let n=ti.get(t);if(n&&n[0]===s)return n[1];let i={error:ts("error",t,s),warn:ts("warn",t,s),info:ts("info",t,s),debug:ts("debug",t,s)};return ti.set(t,[s,i]),i}let to=e=>(e.options&&(e.options={...e.options},delete e.options.headers),e.headers&&(e.headers=Object.fromEntries((e.headers instanceof Headers?[...e.headers]:Object.entries(e.headers)).map(([e,t])=>[e,"authorization"===e.toLowerCase()||"cookie"===e.toLowerCase()||"set-cookie"===e.toLowerCase()?"***":t]))),"retryOfRequestLogID"in e&&(e.retryOfRequestLogID&&(e.retryOf=e.retryOfRequestLogID),delete e.retryOfRequestLogID),e);class ta{constructor(e,t,s){this.iterator=e,k.set(this,void 0),this.controller=t,en(this,k,s,"f")}static fromSSEResponse(e,t,s){let n=!1,i=s?tr(s):console;async function*r(){if(n)throw new ec("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");n=!0;let s=!1;try{for await(let n of tc(e,t))if(!s){if(n.data.startsWith("[DONE]")){s=!0;continue}if(null===n.event){let t;try{t=JSON.parse(n.data)}catch(e){throw i.error("Could not parse message into JSON:",n.data),i.error("From chunk:",n.raw),e}if(t&&t.error)throw new el(void 0,t.error,void 0,e.headers);yield t}}s=!0}catch(e){if(eo(e))return;throw e}finally{s||t.abort()}}return new ta(r,t,s)}static fromReadableStream(e,t,s){let n=!1;async function*i(){let t=new e9;for await(let s of e_(e))for(let e of t.decode(s))yield e;for(let e of t.flush())yield e}return new ta(async function*(){if(n)throw new ec("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");n=!0;let e=!1;try{for await(let t of i())!e&&t&&(yield JSON.parse(t));e=!0}catch(e){if(eo(e))return;throw e}finally{e||t.abort()}},t,s)}[(k=new WeakMap,Symbol.asyncIterator)](){return this.iterator()}tee(){let e=[],t=[],s=this.iterator(),n=n=>({next:()=>{if(0===n.length){let n=s.next();e.push(n),t.push(n)}return n.shift()}});return[new ta(()=>n(e),this.controller,ei(this,k,"f")),new ta(()=>n(t),this.controller,ei(this,k,"f"))]}toReadableStream(){let e,t=this;return eT({async start(){e=t[Symbol.asyncIterator]()},async pull(t){try{let{value:s,done:n}=await e.next();if(n)return t.close();let i=e6(JSON.stringify(s)+"\n");t.enqueue(i)}catch(e){t.error(e)}},async cancel(){await e.return?.()}})}}async function*tc(e,t){if(!e.body){if(t.abort(),void 0!==globalThis.navigator&&"ReactNative"===globalThis.navigator.product)throw new ec("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api");throw new ec("Attempted to iterate over a response with no body")}let s=new th,n=new e9;for await(let t of tl(e_(e.body)))for(let e of n.decode(t)){let t=s.decode(e);t&&(yield t)}for(let e of n.flush()){let t=s.decode(e);t&&(yield t)}}async function*tl(e){let t=new Uint8Array;for await(let s of e){let e;if(null==s)continue;let n=s instanceof ArrayBuffer?new Uint8Array(s):"string"==typeof s?e6(s):s,i=new Uint8Array(t.length+n.length);for(i.set(t),i.set(n,t.length),t=i;-1!==(e=function(e){for(let t=0;t<e.length-1;t++){if(10===e[t]&&10===e[t+1]||13===e[t]&&13===e[t+1])return t+2;if(13===e[t]&&10===e[t+1]&&t+3<e.length&&13===e[t+2]&&10===e[t+3])return t+4}return -1}(t));)yield t.slice(0,e),t=t.slice(e)}t.length>0&&(yield t)}class th{constructor(){this.event=null,this.data=[],this.chunks=[]}decode(e){var t;let s;if(e.endsWith("\r")&&(e=e.substring(0,e.length-1)),!e){if(!this.event&&!this.data.length)return null;let e={event:this.event,data:this.data.join("\n"),raw:this.chunks};return this.event=null,this.data=[],this.chunks=[],e}if(this.chunks.push(e),e.startsWith(":"))return null;let[n,i,r]=-1!==(s=(t=e).indexOf(":"))?[t.substring(0,s),":",t.substring(s+1)]:[t,"",""];return r.startsWith(" ")&&(r=r.substring(1)),"event"===n?this.event=r:"data"===n&&this.data.push(r),null}}class tu extends e5{constructor(){super(...arguments),T.add(this),A.set(this,void 0)}get currentChatCompletionSnapshot(){return ei(this,A,"f")}static fromReadableStream(e){let t=new tu;return t._run(()=>t._fromReadableStream(e)),t}static createChatCompletion(e,t,s){let n=new tu;return n._run(()=>n._runChatCompletion(e,{...t,stream:!0},{...s,headers:{...s?.headers,"X-Stainless-Helper-Method":"stream"}})),n}async _createChatCompletion(e,t,s){let n=s?.signal;n&&(n.aborted&&this.controller.abort(),n.addEventListener("abort",()=>this.controller.abort())),ei(this,T,"m",_).call(this);let i=await e.create({...t,stream:!0},{...s,signal:this.controller.signal});for await(let e of(this._connected(),i))ei(this,T,"m",C).call(this,e);if(i.controller.signal?.aborted)throw new eh;return this._addChatCompletion(ei(this,T,"m",I).call(this))}async _fromReadableStream(e,t){let s,n=t?.signal;n&&(n.aborted&&this.controller.abort(),n.addEventListener("abort",()=>this.controller.abort())),ei(this,T,"m",_).call(this),this._connected();let i=ta.fromReadableStream(e,this.controller);for await(let e of i)s&&s!==e.id&&this._addChatCompletion(ei(this,T,"m",I).call(this)),ei(this,T,"m",C).call(this,e),s=e.id;if(i.controller.signal?.aborted)throw new eh;return this._addChatCompletion(ei(this,T,"m",I).call(this))}[(A=new WeakMap,T=new WeakSet,_=function(){this.ended||en(this,A,void 0,"f")},C=function(e){if(this.ended)return;let t=ei(this,T,"m",P).call(this,e);this._emit("chunk",e,t);let s=e.choices[0]?.delta?.content,n=t.choices[0]?.message;null!=s&&n?.role==="assistant"&&n?.content&&this._emit("content",s,n.content)},I=function(){if(this.ended)throw new ec("stream has ended, this shouldn't happen");let e=ei(this,A,"f");if(!e)throw new ec("request ended without sending any chunks");return en(this,A,void 0,"f"),function(e){let{id:t,choices:s,created:n,model:i,system_fingerprint:r,...o}=e;return{...o,id:t,choices:s.map(({message:t,finish_reason:s,index:n,logprobs:i,...r})=>{if(!s)throw new ec(`missing finish_reason for choice ${n}`);let{content:o=null,function_call:a,tool_calls:c,...l}=t,h=t.role;if(!h)throw new ec(`missing role for choice ${n}`);if(a){let{arguments:e,name:t}=a;if(null==e)throw new ec(`missing function_call.arguments for choice ${n}`);if(!t)throw new ec(`missing function_call.name for choice ${n}`);return{...r,message:{content:o,function_call:{arguments:e,name:t},role:h},finish_reason:s,index:n,logprobs:i}}return c?{...r,index:n,finish_reason:s,logprobs:i,message:{...l,role:h,content:o,tool_calls:c.map((t,s)=>{let{function:i,type:r,id:o,...a}=t,{arguments:c,name:l,...h}=i||{};if(null==o)throw new ec(`missing choices[${n}].tool_calls[${s}].id
${tp(e)}`);if(null==r)throw new ec(`missing choices[${n}].tool_calls[${s}].type
${tp(e)}`);if(null==l)throw new ec(`missing choices[${n}].tool_calls[${s}].function.name
${tp(e)}`);if(null==c)throw new ec(`missing choices[${n}].tool_calls[${s}].function.arguments
${tp(e)}`);return{...a,id:o,type:r,function:{...h,name:l,arguments:c}}})}}:{...r,message:{...l,content:o,role:h},finish_reason:s,index:n,logprobs:i}}),created:n,model:i,object:"chat.completion",...r?{system_fingerprint:r}:{}}}(e)},P=function(e){var t,s,n,i,r;let o=ei(this,A,"f"),{choices:a,...c}=e;for(let{delta:a,finish_reason:l,index:h,logprobs:u=null,...p}of(o?Object.assign(o,c):o=en(this,A,{...c,choices:[]},"f"),e.choices)){let e=o.choices[h];if(e||(e=o.choices[h]={finish_reason:l,index:h,message:{},logprobs:{token_ids:[],token_logprobs:[],tokens:[]},...p}),u&&(console.log({logprobs:u}),e.logprobs||(e.logprobs={token_ids:[],token_logprobs:[],tokens:[]}),(t=e.logprobs).token_ids??(t.token_ids=[]),e.logprobs.token_ids.push(a.token_id??null),(s=e.logprobs).token_logprobs??(s.token_logprobs=[]),e.logprobs.token_logprobs.push(u??null),(n=e.logprobs).tokens??(n.tokens=[]),e.logprobs.tokens.push(a.content??null)),l&&(e.finish_reason=l),Object.assign(e,p),!a)continue;let{content:c,function_call:d,role:m,tool_calls:f,...w}=a;if(Object.assign(e.message,w),c&&(e.message.content=(e.message.content||"")+c),m&&(e.message.role=m),d&&(e.message.function_call?(d.name&&(e.message.function_call.name=d.name),d.arguments&&((i=e.message.function_call).arguments??(i.arguments=""),e.message.function_call.arguments+=d.arguments)):e.message.function_call=d),f)for(let{index:t,id:s,type:n,function:i,...o}of(e.message.tool_calls||(e.message.tool_calls=[]),f)){let a=(r=e.message.tool_calls)[t]??(r[t]={});Object.assign(a,o),s&&(a.id=s),n&&(a.type=n),i&&(a.function??(a.function={arguments:""})),i?.name&&(a.function.name=i.name),i?.arguments&&(a.function.arguments+=i.arguments)}}return o},Symbol.asyncIterator)](){let e=[],t=[],s=!1;return this.on("chunk",s=>{let n=t.shift();n?n.resolve(s):e.push(s)}),this.on("end",()=>{for(let e of(s=!0,t))e.resolve(void 0);t.length=0}),this.on("abort",e=>{for(let n of(s=!0,t))n.reject(e);t.length=0}),this.on("error",e=>{for(let n of(s=!0,t))n.reject(e);t.length=0}),{next:async()=>e.length?{value:e.shift(),done:!1}:s?{value:void 0,done:!0}:new Promise((e,s)=>t.push({resolve:e,reject:s})).then(e=>e?{value:e,done:!1}:{value:void 0,done:!0}),return:async()=>(this.abort(),{value:void 0,done:!0})}}toReadableStream(){return new ta(this[Symbol.asyncIterator].bind(this),this.controller).toReadableStream()}}function tp(e){return JSON.stringify(e)}class td extends eF{create(e,t){return this._client.post("/chat/completions",{body:e,...t,stream:e.stream??!1})}stream(e,t){return tu.createChatCompletion(this._client.chat.completions,e,t)}}class tm extends eF{constructor(){super(...arguments),this.completions=new td(this._client)}}tm.Completions=td;class tf extends eF{list(e){return this._client.get("/tci/sessions",e)}}class tw extends eF{constructor(){super(...arguments),this.sessions=new tf(this._client)}execute(e,t){return this._client.post("/tci/execute",{body:e,...t})}}tw.Sessions=tf;class tg extends eF{create(e,t){return this._client.post("/completions",{body:e,...t,stream:e.stream??!1})}}class ty extends eF{create(e,t){return this._client.post("/embeddings",{body:e,...t})}}class tx extends eF{create(e,t){return this._client.post("/endpoints",{body:e,...t})}retrieve(e,t){return this._client.get(eQ`/endpoints/${e}`,t)}update(e,t,s){return this._client.patch(eQ`/endpoints/${e}`,{body:t,...s})}list(e={},t){return this._client.get("/endpoints",{query:e,...t})}delete(e,t){return this._client.delete(eQ`/endpoints/${e}`,{...t,headers:eJ([{Accept:"*/*"},t?.headers])})}}class tb extends eF{retrieve(e,t){return this._client.get(eQ`/files/${e}`,t)}list(e){return this._client.get("/files",e)}delete(e,t){return this._client.delete(eQ`/files/${e}`,t)}content(e,t){return this._client.get(eQ`/files/${e}/content`,{...t,headers:eJ([{Accept:"application/binary"},t?.headers]),__binaryResponse:!0})}upload(e){throw"please use together-ai/lib/upload"}}class tv extends eF{create(e,t){return this._client.post("/fine-tunes",{body:e,...t})}retrieve(e,t){return this._client.get(eQ`/fine-tunes/${e}`,t)}list(e){return this._client.get("/fine-tunes",e)}cancel(e,t){return this._client.post(eQ`/fine-tunes/${e}/cancel`,t)}download(e,t){return this._client.get("/finetune/download",{query:e,...t})}listEvents(e,t){return this._client.get(eQ`/fine-tunes/${e}/events`,t)}retrieveCheckpoints(e,t){return this._client.get(eQ`/fine-tunes/${e}/checkpoints`,t)}}class tO extends eF{list(e={},t){return this._client.get("/hardware",{query:e,...t})}}class tE extends eF{create(e,t){return this._client.post("/images/generations",{body:e,...t})}}class tR extends eF{retrieve(e,t){return this._client.get(eQ`/jobs/${e}`,t)}list(e){return this._client.get("/jobs",e)}}class tS extends eF{list(e){return this._client.get("/models",e)}upload(e,t){return this._client.post("/models",{body:e,...t})}}async function tk(e,t){let{response:s,requestLogID:n,retryOfRequestLogID:i,startTime:r}=t,o=await (async()=>{if(t.options.stream)return(tr(e).debug("response",s.status,s.url,s.headers,s.body),t.options.__streamClass)?t.options.__streamClass.fromSSEResponse(s,t.controller,e):ta.fromSSEResponse(s,t.controller,e);if(204===s.status)return null;if(t.options.__binaryResponse)return s;let n=s.headers.get("content-type"),i=n?.split(";")[0]?.trim();return i?.includes("application/json")||i?.endsWith("+json")?await s.json():await s.text()})();return tr(e).debug(`[${n}] response parsed`,to({retryOfRequestLogID:i,url:s.url,status:s.status,body:o,durationMs:Date.now()-r})),o}class tT extends Promise{constructor(e,t,s=tk){super(e=>{e(null)}),this.responsePromise=t,this.parseResponse=s,N.set(this,void 0),en(this,N,e,"f")}_thenUnwrap(e){return new tT(ei(this,N,"f"),this.responsePromise,async(t,s)=>e(await this.parseResponse(t,s),s))}asResponse(){return this.responsePromise.then(e=>e.response)}async withResponse(){let[e,t]=await Promise.all([this.parse(),this.asResponse()]);return{data:e,response:t}}parse(){return this.parsedPromise||(this.parsedPromise=this.responsePromise.then(e=>this.parseResponse(ei(this,N,"f"),e))),this.parsedPromise}then(e,t){return this.parse().then(e,t)}catch(e){return this.parse().catch(e)}finally(e){return this.parse().finally(e)}}N=new WeakMap;let tA=e=>void 0!==globalThis.process?globalThis.process.env?.[e]?.trim()??void 0:void 0!==globalThis.Deno?globalThis.Deno.env?.get?.(e)?.trim():void 0;class t_{constructor({baseURL:e=tA("TOGETHER_BASE_URL"),apiKey:t=tA("TOGETHER_API_KEY"),...s}={}){if(M.add(this),L.set(this,void 0),this.chat=new tm(this),this.completions=new tg(this),this.embeddings=new ty(this),this.files=new tb(this),this.fineTune=new tv(this),this.codeInterpreter=new tw(this),this.images=new tE(this),this.audio=new eY(this),this.models=new tS(this),this.jobs=new tR(this),this.endpoints=new tx(this),this.hardware=new tO(this),this.batches=new e0(this),void 0===t)throw new ec("The TOGETHER_API_KEY environment variable is missing or empty; either provide it, or instantiate the Together client with an apiKey option, like new Together({ apiKey: 'My API Key' }).");const n={apiKey:t,...s,baseURL:e||"https://api.together.xyz/v1"};this.baseURL=n.baseURL,this.timeout=n.timeout??D.DEFAULT_TIMEOUT,this.logger=n.logger??console;const i="warn";this.logLevel=i,this.logLevel=te(n.logLevel,"ClientOptions.logLevel",this)??te(tA("TOGETHER_LOG"),"process.env['TOGETHER_LOG']",this)??i,this.fetchOptions=n.fetchOptions,this.maxRetries=n.maxRetries??5,this.fetch=n.fetch??function(){if("undefined"!=typeof fetch)return fetch;throw Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new Together({ fetch })` or polyfill the global, `globalThis.fetch = fetch`")}(),en(this,L,eI,"f"),this._options=n,this.apiKey=t}withOptions(e){return new this.constructor({...this._options,baseURL:this.baseURL,maxRetries:this.maxRetries,timeout:this.timeout,logger:this.logger,logLevel:this.logLevel,fetch:this.fetch,fetchOptions:this.fetchOptions,apiKey:this.apiKey,...e})}rerank(e,t){return this.post("/rerank",{body:e,...t})}defaultQuery(){return this._options.defaultQuery}validateHeaders({values:e,nulls:t}){}async authHeaders(e){return eJ([{Authorization:`Bearer ${this.apiKey}`}])}stringifyQuery(e){return Object.entries(e).filter(([e,t])=>void 0!==t).map(([e,t])=>{if("string"==typeof t||"number"==typeof t||"boolean"==typeof t)return`${encodeURIComponent(e)}=${encodeURIComponent(t)}`;if(null===t)return`${encodeURIComponent(e)}=`;throw new ec(`Cannot stringify type ${typeof t}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`)}).join("&")}getUserAgent(){return`${this.constructor.name}/JS ${eR}`}defaultIdempotencyKey(){return`stainless-node-retry-${er()}`}makeStatusError(e,t,s,n){return el.generate(e,t,s,n)}buildURL(e,t,s){let n=!ei(this,M,"m",U).call(this)&&s||this.baseURL,i=new URL(ev.test(e)?e:n+(n.endsWith("/")&&e.startsWith("/")?e.slice(1):e)),r=this.defaultQuery();return!function(e){if(!e)return!0;for(let t in e)return!1;return!0}(r)&&(t={...r,...t}),"object"==typeof t&&t&&!Array.isArray(t)&&(i.search=this.stringifyQuery(t)),i.toString()}async prepareOptions(e){}async prepareRequest(e,{url:t,options:s}){}get(e,t){return this.methodRequest("get",e,t)}post(e,t){return this.methodRequest("post",e,t)}patch(e,t){return this.methodRequest("patch",e,t)}put(e,t){return this.methodRequest("put",e,t)}delete(e,t){return this.methodRequest("delete",e,t)}methodRequest(e,t,s){return this.request(Promise.resolve(s).then(s=>({method:e,path:t,...s})))}request(e,t=null){return new tT(this,this.makeRequest(e,t,void 0))}async makeRequest(e,t,s){let n=await e,i=n.maxRetries??this.maxRetries;null==t&&(t=i),await this.prepareOptions(n);let{req:r,url:o,timeout:a}=await this.buildRequest(n,{retryCount:i-t});await this.prepareRequest(r,{url:o,options:n});let c="log_"+(0x1000000*Math.random()|0).toString(16).padStart(6,"0"),l=void 0===s?"":`, retryOf: ${s}`,h=Date.now();if(tr(this).debug(`[${c}] sending request`,to({retryOfRequestLogID:s,method:n.method,url:o,options:n,headers:r.headers})),n.signal?.aborted)throw new eh;let u=new AbortController,p=await this.fetchWithTimeout(o,r,a,u).catch(ea),d=Date.now();if(p instanceof Error){let e=`retrying, ${t} attempts remaining`;if(n.signal?.aborted)throw new eh;let i=eo(p)||/timed? ?out/i.test(String(p)+("cause"in p?String(p.cause):""));if(t)return tr(this).info(`[${c}] connection ${i?"timed out":"failed"} - ${e}`),tr(this).debug(`[${c}] connection ${i?"timed out":"failed"} (${e})`,to({retryOfRequestLogID:s,url:o,durationMs:d-h,message:p.message})),this.retryRequest(n,t,s??c);if(tr(this).info(`[${c}] connection ${i?"timed out":"failed"} - error; no more retries left`),tr(this).debug(`[${c}] connection ${i?"timed out":"failed"} (error; no more retries left)`,to({retryOfRequestLogID:s,url:o,durationMs:d-h,message:p.message})),i)throw new ep;throw new eu({cause:p})}let m=`[${c}${l}] ${r.method} ${o} ${p.ok?"succeeded":"failed"} with status ${p.status} in ${d-h}ms`;if(!p.ok){let e=await this.shouldRetry(p);if(t&&e){let e=`retrying, ${t} attempts remaining`;return await eC(p.body),tr(this).info(`${m} - ${e}`),tr(this).debug(`[${c}] response error (${e})`,to({retryOfRequestLogID:s,url:p.url,status:p.status,headers:p.headers,durationMs:d-h})),this.retryRequest(n,t,s??c,p.headers)}let i=e?"error; no more retries left":"error; not retryable";tr(this).info(`${m} - ${i}`);let r=await p.text().catch(e=>ea(e).message),o=(e=>{try{return JSON.parse(e)}catch(e){return}})(r),a=o?void 0:r;throw tr(this).debug(`[${c}] response error (${i})`,to({retryOfRequestLogID:s,url:p.url,status:p.status,headers:p.headers,message:a,durationMs:Date.now()-h})),this.makeStatusError(p.status,o,a,p.headers)}return tr(this).info(m),tr(this).debug(`[${c}] response start`,to({retryOfRequestLogID:s,url:p.url,status:p.status,headers:p.headers,durationMs:d-h})),{response:p,options:n,controller:u,requestLogID:c,retryOfRequestLogID:s,startTime:h}}async fetchWithTimeout(e,t,s,n){let{signal:i,method:r,...o}=t||{};i&&i.addEventListener("abort",()=>n.abort());let a=setTimeout(()=>n.abort(),s),c=globalThis.ReadableStream&&o.body instanceof globalThis.ReadableStream||"object"==typeof o.body&&null!==o.body&&Symbol.asyncIterator in o.body,l={signal:n.signal,...c?{duplex:"half"}:{},method:"GET",...o};r&&(l.method=r.toUpperCase());try{return await this.fetch.call(void 0,e,l)}finally{clearTimeout(a)}}async shouldRetry(e){let t=e.headers.get("x-should-retry");return"true"===t||"false"!==t&&(408===e.status||409===e.status||429===e.status||!!(e.status>=500))}async retryRequest(e,t,s,n){let i,r,o=n?.get("retry-after-ms");if(o){let e=parseFloat(o);Number.isNaN(e)||(i=e)}let a=n?.get("retry-after");if(a&&!i){let e=parseFloat(a);i=Number.isNaN(e)?Date.parse(a)-Date.now():1e3*e}if(!(i&&0<=i&&i<6e4)){let s=e.maxRetries??this.maxRetries;i=this.calculateDefaultRetryTimeoutMillis(t,s)}return await (r=i,new Promise(e=>setTimeout(e,r))),this.makeRequest(e,t-1,s)}calculateDefaultRetryTimeoutMillis(e,t){return Math.min(+Math.pow(2,t-e),10)*(1-.25*Math.random())*1e3}async buildRequest(e,{retryCount:t=0}={}){let s={...e},{method:n,path:i,query:r,defaultBaseURL:o}=s,a=this.buildURL(i,r,o);"timeout"in s&&((e,t)=>{if("number"!=typeof t||!Number.isInteger(t))throw new ec(`${e} must be an integer`);if(t<0)throw new ec(`${e} must be a positive integer`)})("timeout",s.timeout),s.timeout=s.timeout??this.timeout;let{bodyHeaders:c,body:l}=this.buildBody({options:s}),h=await this.buildHeaders({options:e,method:n,bodyHeaders:c,retryCount:t});return{req:{method:n,headers:h,...s.signal&&{signal:s.signal},...globalThis.ReadableStream&&l instanceof globalThis.ReadableStream&&{duplex:"half"},...l&&{body:l},...this.fetchOptions??{},...s.fetchOptions??{}},url:a,timeout:s.timeout}}async buildHeaders({options:e,method:s,bodyHeaders:n,retryCount:i}){let r={};this.idempotencyHeader&&"get"!==s&&(e.idempotencyKey||(e.idempotencyKey=this.defaultIdempotencyKey()),r[this.idempotencyHeader]=e.idempotencyKey);let o=eJ([r,{Accept:"application/json","User-Agent":this.getUserAgent(),"X-Stainless-Retry-Count":String(i),...e.timeout?{"X-Stainless-Timeout":String(Math.trunc(e.timeout/1e3))}:{},...t??(t=(()=>{let e="undefined"!=typeof Deno&&null!=Deno.build?"deno":"undefined"!=typeof EdgeRuntime?"edge":"[object process]"===Object.prototype.toString.call(void 0!==globalThis.process?globalThis.process:0)?"node":"unknown";if("deno"===e)return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":eR,"X-Stainless-OS":ek(Deno.build.os),"X-Stainless-Arch":eS(Deno.build.arch),"X-Stainless-Runtime":"deno","X-Stainless-Runtime-Version":"string"==typeof Deno.version?Deno.version:Deno.version?.deno??"unknown"};if("undefined"!=typeof EdgeRuntime)return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":eR,"X-Stainless-OS":"Unknown","X-Stainless-Arch":`other:${EdgeRuntime}`,"X-Stainless-Runtime":"edge","X-Stainless-Runtime-Version":globalThis.process.version};if("node"===e)return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":eR,"X-Stainless-OS":ek(globalThis.process.platform??"unknown"),"X-Stainless-Arch":eS(globalThis.process.arch??"unknown"),"X-Stainless-Runtime":"node","X-Stainless-Runtime-Version":globalThis.process.version??"unknown"};let t=function(){if("undefined"==typeof navigator||!navigator)return null;for(let{key:e,pattern:t}of[{key:"edge",pattern:/Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"ie",pattern:/MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"ie",pattern:/Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"chrome",pattern:/Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"firefox",pattern:/Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"safari",pattern:/(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/}]){let s=t.exec(navigator.userAgent);if(s){let t=s[1]||0,n=s[2]||0,i=s[3]||0;return{browser:e,version:`${t}.${n}.${i}`}}}return null}();return t?{"X-Stainless-Lang":"js","X-Stainless-Package-Version":eR,"X-Stainless-OS":"Unknown","X-Stainless-Arch":"unknown","X-Stainless-Runtime":`browser:${t.browser}`,"X-Stainless-Runtime-Version":t.version}:{"X-Stainless-Lang":"js","X-Stainless-Package-Version":eR,"X-Stainless-OS":"Unknown","X-Stainless-Arch":"unknown","X-Stainless-Runtime":"unknown","X-Stainless-Runtime-Version":"unknown"}})())},await this.authHeaders(e),this._options.defaultHeaders,n,e.headers]);return this.validateHeaders(o),o.values}buildBody({options:{body:e,headers:t}}){if(!e)return{bodyHeaders:void 0,body:void 0};let s=eJ([t]);return ArrayBuffer.isView(e)||e instanceof ArrayBuffer||e instanceof DataView||"string"==typeof e&&s.values.has("content-type")||e instanceof Blob||e instanceof FormData||e instanceof URLSearchParams||globalThis.ReadableStream&&e instanceof globalThis.ReadableStream?{bodyHeaders:void 0,body:e}:"object"==typeof e&&(Symbol.asyncIterator in e||Symbol.iterator in e&&"next"in e&&"function"==typeof e.next)?{bodyHeaders:void 0,body:eA(e)}:ei(this,L,"f").call(this,{body:e,headers:s})}}D=t_,L=new WeakMap,M=new WeakSet,U=function(){return"https://api.together.xyz/v1"!==this.baseURL},t_.Together=D,t_.DEFAULT_TIMEOUT=6e4,t_.TogetherError=ec,t_.APIError=el,t_.APIConnectionError=eu,t_.APIConnectionTimeoutError=ep,t_.APIUserAbortError=eh,t_.NotFoundError=ew,t_.ConflictError=eg,t_.RateLimitError=ex,t_.BadRequestError=ed,t_.AuthenticationError=em,t_.InternalServerError=eb,t_.PermissionDeniedError=ef,t_.UnprocessableEntityError=ey,t_.toFile=eB,t_.Chat=tm,t_.Completions=tg,t_.Embeddings=ty,t_.Files=tb,t_.FineTuneResource=tv,t_.CodeInterpreter=tw,t_.Images=tE,t_.Audio=eY,t_.Models=tS,t_.Jobs=tR,t_.Endpoints=tx,t_.Hardware=tO,t_.Batches=e0;let tC={apiKey:process.env.TOGETHER_API_KEY};process.env.HELICONE_API_KEY&&(tC.baseURL="https://together.helicone.ai/v1",tC.defaultHeaders={"Helicone-Auth":`Bearer ${process.env.HELICONE_API_KEY}`,"Helicone-Property-Appname":"receipthero"});let tI=new t_(tC);var tP=e.i(83801);let tN=tP.z.object({id:tP.z.string(),fileName:tP.z.string(),date:tP.z.string(),vendor:tP.z.string(),category:tP.z.string(),paymentMethod:tP.z.string(),taxAmount:tP.z.number(),amount:tP.z.number(),currency:tP.z.string().default("USD"),originalAmount:tP.z.number().optional(),originalTaxAmount:tP.z.number().optional(),exchangeRate:tP.z.number().optional(),thumbnail:tP.z.string(),base64:tP.z.string(),mimeType:tP.z.string()});var tM=e.i(90590),tD=e.i(66680);let tL=tD.default.webcrypto?.subtle||{};var tU=Object.defineProperty,tj={},t$={UpstashError:()=>tW,UrlError:()=>tq};for(var tz in t$)tU(tj,tz,{get:t$[tz],enumerable:!0});var tW=class extends Error{constructor(e){super(e),this.name="UpstashError"}},tq=class extends Error{constructor(e){super(`Upstash Redis client was passed an invalid URL. You should pass a URL starting with https. Received: "${e}". `),this.name="UrlError"}};function tB(e){try{return function e(t){let s=Array.isArray(t)?t.map(t=>{try{return e(t)}catch{return t}}):JSON.parse(t);return"number"==typeof s&&s.toString()!==t?t:s}(e)}catch{return e}}function tK(e){return[e[0],...tB(e.slice(1))]}function tF(e){let[t,s]=e,n=[];for(let e=0;e<s.length;e+=2)n.push({key:s[e],type:s[e+1]});return[t,n]}var tG=class{baseUrl;headers;options;readYourWrites;upstashSyncToken="";hasCredentials;retry;constructor(e){if(this.options={backend:e.options?.backend,agent:e.agent,responseEncoding:e.responseEncoding??"base64",cache:e.cache,signal:e.signal,keepAlive:e.keepAlive??!0},this.upstashSyncToken="",this.readYourWrites=e.readYourWrites??!0,this.baseUrl=(e.baseUrl||"").replace(/\/$/,""),this.baseUrl&&!/^https?:\/\/[^\s#$./?].\S*$/.test(this.baseUrl))throw new tq(this.baseUrl);this.headers={"Content-Type":"application/json",...e.headers},this.hasCredentials=!!(this.baseUrl&&this.headers.authorization.split(" ")[1]),"base64"===this.options.responseEncoding&&(this.headers["Upstash-Encoding"]="base64"),this.retry="boolean"!=typeof e.retry||e.retry?{attempts:e.retry?.retries??5,backoff:e.retry?.backoff??(e=>50*Math.exp(e))}:{attempts:1,backoff:()=>0}}mergeTelemetry(e){this.headers=tJ(this.headers,"Upstash-Telemetry-Runtime",e.runtime),this.headers=tJ(this.headers,"Upstash-Telemetry-Platform",e.platform),this.headers=tJ(this.headers,"Upstash-Telemetry-Sdk",e.sdk)}async request(e){let t=function(...e){let t={};for(let s of e)if(s)for(let[e,n]of Object.entries(s))null!=n&&(t[e]=n);return t}(this.headers,e.headers??{}),s=[this.baseUrl,...e.path??[]].join("/"),n="text/event-stream"===t.Accept,i=e.signal??this.options.signal,r="function"==typeof i,o={cache:this.options.cache,method:"POST",headers:t,body:JSON.stringify(e.body),keepalive:this.options.keepAlive,agent:this.options.agent,signal:r?i():i,backend:this.options.backend};if(this.hasCredentials||console.warn("[Upstash Redis] Redis client was initialized without url or token. Failed to execute command."),this.readYourWrites){let e=this.upstashSyncToken;this.headers["upstash-sync-token"]=e}let a=null,c=null;for(let e=0;e<=this.retry.attempts;e++)try{a=await fetch(s,o);break}catch(t){if(o.signal?.aborted&&r)throw t;if(o.signal?.aborted){a=new Response(new Blob([JSON.stringify({result:o.signal.reason??"Aborted"})]),{status:200,statusText:o.signal.reason??"Aborted"});break}c=t,e<this.retry.attempts&&await new Promise(t=>setTimeout(t,this.retry.backoff(e)))}if(!a)throw c??Error("Exhausted all retries");if(!a.ok){let t=await a.json();throw new tW(`${t.error}, command was: ${JSON.stringify(e.body)}`)}if(this.readYourWrites){let e=a.headers;this.upstashSyncToken=e.get("upstash-sync-token")??""}if(n&&e&&e.onMessage&&a.body){let t=a.body.getReader(),s=new TextDecoder;return(async()=>{try{for(;;){let{value:n,done:i}=await t.read();if(i)break;for(let t of s.decode(n).split("\n"))if(t.startsWith("data: ")){let s=t.slice(6);e.onMessage?.(s)}}}catch(e){e instanceof Error&&"AbortError"===e.name||console.error("Stream reading error:",e)}finally{try{await t.cancel()}catch{}}})(),{result:1}}let l=await a.json();if(this.readYourWrites){let e=a.headers;this.upstashSyncToken=e.get("upstash-sync-token")??""}return"base64"===this.options.responseEncoding?Array.isArray(l)?l.map(({result:e,error:t})=>({result:tV(e),error:t})):{result:tV(l.result),error:l.error}:l}};function tH(e){let t="";try{let s=atob(e),n=s.length,i=new Uint8Array(n);for(let e=0;e<n;e++)i[e]=s.charCodeAt(e);t=new TextDecoder().decode(i)}catch{t=e}return t}function tV(e){let t;switch(typeof e){case"undefined":return e;case"number":t=e;break;case"object":t=Array.isArray(e)?e.map(e=>"string"==typeof e?tH(e):Array.isArray(e)?e.map(e=>tV(e)):e):null;break;case"string":t="OK"===e?"OK":tH(e)}return t}function tJ(e,t,s){return s&&(e[t]=e[t]?[e[t],s].join(","):s),e}var tY=e=>{switch(typeof e){case"string":case"number":case"boolean":return e;default:return JSON.stringify(e)}},tX=class{command;serialize;deserialize;headers;path;onMessage;isStreaming;signal;constructor(e,t){if(this.serialize=tY,this.deserialize=t?.automaticDeserialization===void 0||t.automaticDeserialization?t?.deserialize??tB:e=>e,this.command=e.map(e=>this.serialize(e)),this.headers=t?.headers,this.path=t?.path,this.onMessage=t?.streamOptions?.onMessage,this.isStreaming=t?.streamOptions?.isStreaming??!1,this.signal=t?.streamOptions?.signal,t?.latencyLogging){const e=this.exec.bind(this);this.exec=async t=>{let s=performance.now(),n=await e(t),i=(performance.now()-s).toFixed(2);return console.log(`Latency for \x1b[38;2;19;185;39m${this.command[0].toString().toUpperCase()}\x1b[0m: \x1b[38;2;0;255;255m${i} ms\x1b[0m`),n}}}async exec(e){let{result:t,error:s}=await e.request({body:this.command,path:this.path,upstashSyncToken:e.upstashSyncToken,headers:this.headers,onMessage:this.onMessage,isStreaming:this.isStreaming,signal:this.signal});if(s)throw new tW(s);if(void 0===t)throw TypeError("Request did not return a result");return this.deserialize(t)}},tZ=class extends tX{constructor(e,t){const s=["hrandfield",e[0]];"number"==typeof e[1]&&s.push(e[1]),e[2]&&s.push("WITHVALUES"),super(s,{deserialize:e[2]?e=>(function(e){if(0===e.length)return null;let t={};for(let s=0;s<e.length;s+=2){let n=e[s],i=e[s+1];try{t[n]=JSON.parse(i)}catch{t[n]=i}}return t})(e):t?.deserialize,...t})}},tQ=class extends tX{constructor(e,t){super(["append",...e],t)}},t0=class extends tX{constructor([e,t,s],n){const i=["bitcount",e];"number"==typeof t&&i.push(t),"number"==typeof s&&i.push(s),super(i,n)}},t1=class{constructor(e,t,s,n=e=>e.exec(this.client)){this.client=t,this.opts=s,this.execOperation=n,this.command=["bitfield",...e]}command;chain(...e){return this.command.push(...e),this}get(...e){return this.chain("get",...e)}set(...e){return this.chain("set",...e)}incrby(...e){return this.chain("incrby",...e)}overflow(e){return this.chain("overflow",e)}exec(){let e=new tX(this.command,this.opts);return this.execOperation(e)}},t2=class extends tX{constructor(e,t){super(["bitop",...e],t)}},t3=class extends tX{constructor(e,t){super(["bitpos",...e],t)}},t4=class extends tX{constructor([e,t,s],n){super(["COPY",e,t,...s?.replace?["REPLACE"]:[]],{...n,deserialize:e=>e>0?"COPIED":"NOT_COPIED"})}},t5=class extends tX{constructor(e){super(["dbsize"],e)}},t6=class extends tX{constructor(e,t){super(["decr",...e],t)}},t8=class extends tX{constructor(e,t){super(["decrby",...e],t)}},t9=class extends tX{constructor(e,t){super(["del",...e],t)}},t7=class extends tX{constructor(e,t){super(["echo",...e],t)}},se=class extends tX{constructor([e,t,s],n){super(["eval_ro",e,t.length,...t,...s??[]],n)}},st=class extends tX{constructor([e,t,s],n){super(["eval",e,t.length,...t,...s??[]],n)}},ss=class extends tX{constructor([e,t,s],n){super(["evalsha_ro",e,t.length,...t,...s??[]],n)}},sn=class extends tX{constructor([e,t,s],n){super(["evalsha",e,t.length,...t,...s??[]],n)}},si=class extends tX{constructor(e,t){super(e.map(e=>"string"==typeof e?e:String(e)),t)}},sr=class extends tX{constructor(e,t){super(["exists",...e],t)}},so=class extends tX{constructor(e,t){super(["expire",...e.filter(Boolean)],t)}},sa=class extends tX{constructor(e,t){super(["expireat",...e],t)}},sc=class extends tX{constructor(e,t){const s=["flushall"];e&&e.length>0&&e[0].async&&s.push("async"),super(s,t)}},sl=class extends tX{constructor([e],t){const s=["flushdb"];e?.async&&s.push("async"),super(s,t)}},sh=class extends tX{constructor([e,t,...s],n){const i=["geoadd",e];"nx"in t&&t.nx?i.push("nx"):"xx"in t&&t.xx&&i.push("xx"),"ch"in t&&t.ch&&i.push("ch"),"latitude"in t&&t.latitude&&i.push(t.longitude,t.latitude,t.member),i.push(...s.flatMap(({latitude:e,longitude:t,member:s})=>[t,e,s])),super(i,n)}},su=class extends tX{constructor([e,t,s,n="M"],i){super(["GEODIST",e,t,s,n],i)}},sp=class extends tX{constructor(e,t){const[s]=e;super(["GEOHASH",s,...Array.isArray(e[1])?e[1]:e.slice(1)],t)}},sd=class extends tX{constructor(e,t){const[s]=e;super(["GEOPOS",s,...Array.isArray(e[1])?e[1]:e.slice(1)],{deserialize:e=>(function(e){let t=[];for(let s of e)s?.[0]&&s?.[1]&&t.push({lng:Number.parseFloat(s[0]),lat:Number.parseFloat(s[1])});return t})(e),...t})}},sm=class extends tX{constructor([e,t,s,n,i],r){const o=["GEOSEARCH",e];("FROMMEMBER"===t.type||"frommember"===t.type)&&o.push(t.type,t.member),("FROMLONLAT"===t.type||"fromlonlat"===t.type)&&o.push(t.type,t.coordinate.lon,t.coordinate.lat),("BYRADIUS"===s.type||"byradius"===s.type)&&o.push(s.type,s.radius,s.radiusType),("BYBOX"===s.type||"bybox"===s.type)&&o.push(s.type,s.rect.width,s.rect.height,s.rectType),o.push(n),i?.count&&o.push("COUNT",i.count.limit,...i.count.any?["ANY"]:[]),super([...o,...i?.withCoord?["WITHCOORD"]:[],...i?.withDist?["WITHDIST"]:[],...i?.withHash?["WITHHASH"]:[]],{deserialize:e=>i?.withCoord||i?.withDist||i?.withHash?e.map(e=>{let t=1,s={};try{s.member=JSON.parse(e[0])}catch{s.member=e[0]}return i.withDist&&(s.dist=Number.parseFloat(e[t++])),i.withHash&&(s.hash=e[t++].toString()),i.withCoord&&(s.coord={long:Number.parseFloat(e[t][0]),lat:Number.parseFloat(e[t][1])}),s}):e.map(e=>{try{return{member:JSON.parse(e)}}catch{return{member:e}}}),...r})}},sf=class extends tX{constructor([e,t,s,n,i,r],o){const a=["GEOSEARCHSTORE",e,t];("FROMMEMBER"===s.type||"frommember"===s.type)&&a.push(s.type,s.member),("FROMLONLAT"===s.type||"fromlonlat"===s.type)&&a.push(s.type,s.coordinate.lon,s.coordinate.lat),("BYRADIUS"===n.type||"byradius"===n.type)&&a.push(n.type,n.radius,n.radiusType),("BYBOX"===n.type||"bybox"===n.type)&&a.push(n.type,n.rect.width,n.rect.height,n.rectType),a.push(i),r?.count&&a.push("COUNT",r.count.limit,...r.count.any?["ANY"]:[]),super([...a,...r?.storeDist?["STOREDIST"]:[]],o)}},sw=class extends tX{constructor(e,t){super(["get",...e],t)}},sg=class extends tX{constructor(e,t){super(["getbit",...e],t)}},sy=class extends tX{constructor(e,t){super(["getdel",...e],t)}},sx=class extends tX{constructor([e,t],s){const n=["getex",e];t&&("ex"in t&&"number"==typeof t.ex?n.push("ex",t.ex):"px"in t&&"number"==typeof t.px?n.push("px",t.px):"exat"in t&&"number"==typeof t.exat?n.push("exat",t.exat):"pxat"in t&&"number"==typeof t.pxat?n.push("pxat",t.pxat):"persist"in t&&t.persist&&n.push("persist")),super(n,s)}},sb=class extends tX{constructor(e,t){super(["getrange",...e],t)}},sv=class extends tX{constructor(e,t){super(["getset",...e],t)}},sO=class extends tX{constructor(e,t){super(["hdel",...e],t)}},sE=class extends tX{constructor(e,t){super(["hexists",...e],t)}},sR=class extends tX{constructor(e,t){const[s,n,i,r]=e,o=Array.isArray(n)?n:[n];super(["hexpire",s,i,...r?[r]:[],"FIELDS",o.length,...o],t)}},sS=class extends tX{constructor(e,t){const[s,n,i,r]=e,o=Array.isArray(n)?n:[n];super(["hexpireat",s,i,...r?[r]:[],"FIELDS",o.length,...o],t)}},sk=class extends tX{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["hexpiretime",s,"FIELDS",i.length,...i],t)}},sT=class extends tX{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["hpersist",s,"FIELDS",i.length,...i],t)}},sA=class extends tX{constructor(e,t){const[s,n,i,r]=e,o=Array.isArray(n)?n:[n];super(["hpexpire",s,i,...r?[r]:[],"FIELDS",o.length,...o],t)}},s_=class extends tX{constructor(e,t){const[s,n,i,r]=e,o=Array.isArray(n)?n:[n];super(["hpexpireat",s,i,...r?[r]:[],"FIELDS",o.length,...o],t)}},sC=class extends tX{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["hpexpiretime",s,"FIELDS",i.length,...i],t)}},sI=class extends tX{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["hpttl",s,"FIELDS",i.length,...i],t)}},sP=class extends tX{constructor(e,t){super(["hget",...e],t)}},sN=class extends tX{constructor(e,t){super(["hgetall",...e],{deserialize:e=>(function(e){if(0===e.length)return null;let t={};for(let s=0;s<e.length;s+=2){let n=e[s],i=e[s+1];try{let e=!Number.isNaN(Number(i))&&!Number.isSafeInteger(Number(i));t[n]=e?i:JSON.parse(i)}catch{t[n]=i}}return t})(e),...t})}},sM=class extends tX{constructor(e,t){super(["hincrby",...e],t)}},sD=class extends tX{constructor(e,t){super(["hincrbyfloat",...e],t)}},sL=class extends tX{constructor([e],t){super(["hkeys",e],t)}},sU=class extends tX{constructor(e,t){super(["hlen",...e],t)}},sj=class extends tX{constructor([e,...t],s){super(["hmget",e,...t],{deserialize:e=>(function(e,t){if(t.every(e=>null===e))return null;let s={};for(let[n,i]of e.entries())try{s[i]=JSON.parse(t[n])}catch{s[i]=t[n]}return s})(t,e),...s})}},s$=class extends tX{constructor([e,t],s){super(["hmset",e,...Object.entries(t).flatMap(([e,t])=>[e,t])],s)}},sz=class extends tX{constructor([e,t,s],n){const i=["hscan",e,t];s?.match&&i.push("match",s.match),"number"==typeof s?.count&&i.push("count",s.count),super(i,{deserialize:tK,...n})}},sW=class extends tX{constructor([e,t],s){super(["hset",e,...Object.entries(t).flatMap(([e,t])=>[e,t])],s)}},sq=class extends tX{constructor(e,t){super(["hsetnx",...e],t)}},sB=class extends tX{constructor(e,t){super(["hstrlen",...e],t)}},sK=class extends tX{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["httl",s,"FIELDS",i.length,...i],t)}},sF=class extends tX{constructor(e,t){super(["hvals",...e],t)}},sG=class extends tX{constructor(e,t){super(["incr",...e],t)}},sH=class extends tX{constructor(e,t){super(["incrby",...e],t)}},sV=class extends tX{constructor(e,t){super(["incrbyfloat",...e],t)}},sJ=class extends tX{constructor(e,t){super(["JSON.ARRAPPEND",...e],t)}},sY=class extends tX{constructor(e,t){super(["JSON.ARRINDEX",...e],t)}},sX=class extends tX{constructor(e,t){super(["JSON.ARRINSERT",...e],t)}},sZ=class extends tX{constructor(e,t){super(["JSON.ARRLEN",e[0],e[1]??"$"],t)}},sQ=class extends tX{constructor(e,t){super(["JSON.ARRPOP",...e],t)}},s0=class extends tX{constructor(e,t){const s=e[1]??"$";super(["JSON.ARRTRIM",e[0],s,e[2]??0,e[3]??0],t)}},s1=class extends tX{constructor(e,t){super(["JSON.CLEAR",...e],t)}},s2=class extends tX{constructor(e,t){super(["JSON.DEL",...e],t)}},s3=class extends tX{constructor(e,t){super(["JSON.FORGET",...e],t)}},s4=class extends tX{constructor(e,t){const s=["JSON.GET"];"string"==typeof e[1]?s.push(...e):(s.push(e[0]),e[1]&&(e[1].indent&&s.push("INDENT",e[1].indent),e[1].newline&&s.push("NEWLINE",e[1].newline),e[1].space&&s.push("SPACE",e[1].space)),s.push(...e.slice(2))),super(s,t)}},s5=class extends tX{constructor(e,t){super(["JSON.MERGE",...e],t)}},s6=class extends tX{constructor(e,t){super(["JSON.MGET",...e[0],e[1]],t)}},s8=class extends tX{constructor(e,t){const s=["JSON.MSET"];for(const t of e)s.push(t.key,t.path,t.value);super(s,t)}},s9=class extends tX{constructor(e,t){super(["JSON.NUMINCRBY",...e],t)}},s7=class extends tX{constructor(e,t){super(["JSON.NUMMULTBY",...e],t)}},ne=class extends tX{constructor(e,t){super(["JSON.OBJKEYS",...e],t)}},nt=class extends tX{constructor(e,t){super(["JSON.OBJLEN",...e],t)}},ns=class extends tX{constructor(e,t){super(["JSON.RESP",...e],t)}},nn=class extends tX{constructor(e,t){const s=["JSON.SET",e[0],e[1],e[2]];e[3]&&(e[3].nx?s.push("NX"):e[3].xx&&s.push("XX")),super(s,t)}},ni=class extends tX{constructor(e,t){super(["JSON.STRAPPEND",...e],t)}},nr=class extends tX{constructor(e,t){super(["JSON.STRLEN",...e],t)}},no=class extends tX{constructor(e,t){super(["JSON.TOGGLE",...e],t)}},na=class extends tX{constructor(e,t){super(["JSON.TYPE",...e],t)}},nc=class extends tX{constructor(e,t){super(["keys",...e],t)}},nl=class extends tX{constructor(e,t){super(["lindex",...e],t)}},nh=class extends tX{constructor(e,t){super(["linsert",...e],t)}},nu=class extends tX{constructor(e,t){super(["llen",...e],t)}},np=class extends tX{constructor(e,t){super(["lmove",...e],t)}},nd=class extends tX{constructor(e,t){const[s,n,i,r]=e;super(["LMPOP",s,...n,i,...r?["COUNT",r]:[]],t)}},nm=class extends tX{constructor(e,t){super(["lpop",...e],t)}},nf=class extends tX{constructor(e,t){const s=["lpos",e[0],e[1]];"number"==typeof e[2]?.rank&&s.push("rank",e[2].rank),"number"==typeof e[2]?.count&&s.push("count",e[2].count),"number"==typeof e[2]?.maxLen&&s.push("maxLen",e[2].maxLen),super(s,t)}},nw=class extends tX{constructor(e,t){super(["lpush",...e],t)}},ng=class extends tX{constructor(e,t){super(["lpushx",...e],t)}},ny=class extends tX{constructor(e,t){super(["lrange",...e],t)}},nx=class extends tX{constructor(e,t){super(["lrem",...e],t)}},nb=class extends tX{constructor(e,t){super(["lset",...e],t)}},nv=class extends tX{constructor(e,t){super(["ltrim",...e],t)}},nO=class extends tX{constructor(e,t){super(["mget",...Array.isArray(e[0])?e[0]:e],t)}},nE=class extends tX{constructor([e],t){super(["mset",...Object.entries(e).flatMap(([e,t])=>[e,t])],t)}},nR=class extends tX{constructor([e],t){super(["msetnx",...Object.entries(e).flat()],t)}},nS=class extends tX{constructor(e,t){super(["persist",...e],t)}},nk=class extends tX{constructor(e,t){super(["pexpire",...e],t)}},nT=class extends tX{constructor(e,t){super(["pexpireat",...e],t)}},nA=class extends tX{constructor(e,t){super(["pfadd",...e],t)}},n_=class extends tX{constructor(e,t){super(["pfcount",...e],t)}},nC=class extends tX{constructor(e,t){super(["pfmerge",...e],t)}},nI=class extends tX{constructor(e,t){const s=["ping"];e?.[0]!==void 0&&s.push(e[0]),super(s,t)}},nP=class extends tX{constructor(e,t){super(["psetex",...e],t)}},nN=class extends tX{constructor(e,t){super(["pttl",...e],t)}},nM=class extends tX{constructor(e,t){super(["publish",...e],t)}},nD=class extends tX{constructor(e){super(["randomkey"],e)}},nL=class extends tX{constructor(e,t){super(["rename",...e],t)}},nU=class extends tX{constructor(e,t){super(["renamenx",...e],t)}},nj=class extends tX{constructor(e,t){super(["rpop",...e],t)}},n$=class extends tX{constructor(e,t){super(["rpush",...e],t)}},nz=class extends tX{constructor(e,t){super(["rpushx",...e],t)}},nW=class extends tX{constructor(e,t){super(["sadd",...e],t)}},nq=class extends tX{constructor([e,t],s){const n=["scan",e];t?.match&&n.push("match",t.match),"number"==typeof t?.count&&n.push("count",t.count),t&&"withType"in t&&!0===t.withType?n.push("withtype"):t&&"type"in t&&t.type&&t.type.length>0&&n.push("type",t.type),super(n,{deserialize:t?.withType?tF:tK,...s})}},nB=class extends tX{constructor(e,t){super(["scard",...e],t)}},nK=class extends tX{constructor(e,t){super(["script","exists",...e],{deserialize:e=>e,...t})}},nF=class extends tX{constructor([e],t){const s=["script","flush"];e?.sync?s.push("sync"):e?.async&&s.push("async"),super(s,t)}},nG=class extends tX{constructor(e,t){super(["script","load",...e],t)}},nH=class extends tX{constructor(e,t){super(["sdiff",...e],t)}},nV=class extends tX{constructor(e,t){super(["sdiffstore",...e],t)}},nJ=class extends tX{constructor([e,t,s],n){const i=["set",e,t];s&&("nx"in s&&s.nx?i.push("nx"):"xx"in s&&s.xx&&i.push("xx"),"get"in s&&s.get&&i.push("get"),"ex"in s&&"number"==typeof s.ex?i.push("ex",s.ex):"px"in s&&"number"==typeof s.px?i.push("px",s.px):"exat"in s&&"number"==typeof s.exat?i.push("exat",s.exat):"pxat"in s&&"number"==typeof s.pxat?i.push("pxat",s.pxat):"keepTtl"in s&&s.keepTtl&&i.push("keepTtl")),super(i,n)}},nY=class extends tX{constructor(e,t){super(["setbit",...e],t)}},nX=class extends tX{constructor(e,t){super(["setex",...e],t)}},nZ=class extends tX{constructor(e,t){super(["setnx",...e],t)}},nQ=class extends tX{constructor(e,t){super(["setrange",...e],t)}},n0=class extends tX{constructor(e,t){super(["sinter",...e],t)}},n1=class extends tX{constructor(e,t){super(["sinterstore",...e],t)}},n2=class extends tX{constructor(e,t){super(["sismember",...e],t)}},n3=class extends tX{constructor(e,t){super(["smembers",...e],t)}},n4=class extends tX{constructor(e,t){super(["smismember",e[0],...e[1]],t)}},n5=class extends tX{constructor(e,t){super(["smove",...e],t)}},n6=class extends tX{constructor([e,t],s){const n=["spop",e];"number"==typeof t&&n.push(t),super(n,s)}},n8=class extends tX{constructor([e,t],s){const n=["srandmember",e];"number"==typeof t&&n.push(t),super(n,s)}},n9=class extends tX{constructor(e,t){super(["srem",...e],t)}},n7=class extends tX{constructor([e,t,s],n){const i=["sscan",e,t];s?.match&&i.push("match",s.match),"number"==typeof s?.count&&i.push("count",s.count),super(i,{deserialize:tK,...n})}},ie=class extends tX{constructor(e,t){super(["strlen",...e],t)}},it=class extends tX{constructor(e,t){super(["sunion",...e],t)}},is=class extends tX{constructor(e,t){super(["sunionstore",...e],t)}},ii=class extends tX{constructor(e){super(["time"],e)}},ir=class extends tX{constructor(e,t){super(["touch",...e],t)}},io=class extends tX{constructor(e,t){super(["ttl",...e],t)}},ia=class extends tX{constructor(e,t){super(["type",...e],t)}},ic=class extends tX{constructor(e,t){super(["unlink",...e],t)}},il=class extends tX{constructor([e,t,s],n){super(["XACK",e,t,...Array.isArray(s)?[...s]:[s]],n)}},ih=class extends tX{constructor([e,t,s,n],i){const r=["XADD",e];for(const[e,i]of(n&&(n.nomkStream&&r.push("NOMKSTREAM"),n.trim&&(r.push(n.trim.type,n.trim.comparison,n.trim.threshold),void 0!==n.trim.limit&&r.push("LIMIT",n.trim.limit))),r.push(t),Object.entries(s)))r.push(e,i);super(r,i)}},iu=class extends tX{constructor([e,t,s,n,i,r],o){const a=[];r?.count&&a.push("COUNT",r.count),r?.justId&&a.push("JUSTID"),super(["XAUTOCLAIM",e,t,s,n,i,...a],o)}},ip=class extends tX{constructor([e,t,s,n,i,r],o){const a=Array.isArray(i)?[...i]:[i],c=[];r?.idleMS&&c.push("IDLE",r.idleMS),r?.idleMS&&c.push("TIME",r.timeMS),r?.retryCount&&c.push("RETRYCOUNT",r.retryCount),r?.force&&c.push("FORCE"),r?.justId&&c.push("JUSTID"),r?.lastId&&c.push("LASTID",r.lastId),super(["XCLAIM",e,t,s,n,...a,...c],o)}},id=class extends tX{constructor([e,t],s){super(["XDEL",e,...Array.isArray(t)?[...t]:[t]],s)}},im=class extends tX{constructor([e,t],s){const n=["XGROUP"];switch(t.type){case"CREATE":n.push("CREATE",e,t.group,t.id),t.options&&(t.options.MKSTREAM&&n.push("MKSTREAM"),void 0!==t.options.ENTRIESREAD&&n.push("ENTRIESREAD",t.options.ENTRIESREAD.toString()));break;case"CREATECONSUMER":n.push("CREATECONSUMER",e,t.group,t.consumer);break;case"DELCONSUMER":n.push("DELCONSUMER",e,t.group,t.consumer);break;case"DESTROY":n.push("DESTROY",e,t.group);break;case"SETID":n.push("SETID",e,t.group,t.id),t.options?.ENTRIESREAD!==void 0&&n.push("ENTRIESREAD",t.options.ENTRIESREAD.toString());break;default:throw Error("Invalid XGROUP")}super(n,s)}},iw=class extends tX{constructor([e,t],s){const n=[];"CONSUMERS"===t.type?n.push("CONSUMERS",e,t.group):n.push("GROUPS",e),super(["XINFO",...n],s)}},ig=class extends tX{constructor(e,t){super(["XLEN",...e],t)}},iy=class extends tX{constructor([e,t,s,n,i,r],o){super(["XPENDING",e,t,...r?.idleTime?["IDLE",r.idleTime]:[],s,n,i,...r?.consumer===void 0?[]:Array.isArray(r.consumer)?[...r.consumer]:[r.consumer]],o)}},ix=class extends tX{constructor([e,t,s,n],i){const r=["XRANGE",e,t,s];"number"==typeof n&&r.push("COUNT",n),super(r,{deserialize:e=>(function(e){let t={};for(let s of e)for(let e=0;e<s.length;e+=2){let n=s[e],i=s[e+1];n in t||(t[n]={});for(let e=0;e<i.length;e+=2){let s=i[e],r=i[e+1];try{t[n][s]=JSON.parse(r)}catch{t[n][s]=r}}}return t})(e),...i})}},ib=class extends tX{constructor([e,t,s],n){if(Array.isArray(e)&&Array.isArray(t)&&e.length!==t.length)throw Error("ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified");const i=[];"number"==typeof s?.count&&i.push("COUNT",s.count),"number"==typeof s?.blockMS&&i.push("BLOCK",s.blockMS),i.push("STREAMS",...Array.isArray(e)?[...e]:[e],...Array.isArray(t)?[...t]:[t]),super(["XREAD",...i],n)}},iv=class extends tX{constructor([e,t,s,n,i],r){if(Array.isArray(s)&&Array.isArray(n)&&s.length!==n.length)throw Error("ERR Unbalanced XREADGROUP list of streams: for each stream key an ID or '$' must be specified");const o=[];"number"==typeof i?.count&&o.push("COUNT",i.count),"number"==typeof i?.blockMS&&o.push("BLOCK",i.blockMS),"boolean"==typeof i?.NOACK&&i.NOACK&&o.push("NOACK"),o.push("STREAMS",...Array.isArray(s)?[...s]:[s],...Array.isArray(n)?[...n]:[n]),super(["XREADGROUP","GROUP",e,t,...o],r)}},iO=class extends tX{constructor([e,t,s,n],i){const r=["XREVRANGE",e,t,s];"number"==typeof n&&r.push("COUNT",n),super(r,{deserialize:e=>(function(e){let t={};for(let s of e)for(let e=0;e<s.length;e+=2){let n=s[e],i=s[e+1];n in t||(t[n]={});for(let e=0;e<i.length;e+=2){let s=i[e],r=i[e+1];try{t[n][s]=JSON.parse(r)}catch{t[n][s]=r}}}return t})(e),...i})}},iE=class extends tX{constructor([e,t],s){const{limit:n,strategy:i,threshold:r,exactness:o="~"}=t;super(["XTRIM",e,i,o,r,...n?["LIMIT",n]:[]],s)}},iR=class extends tX{constructor([e,t,...s],n){const i=["zadd",e];"nx"in t&&t.nx?i.push("nx"):"xx"in t&&t.xx&&i.push("xx"),"ch"in t&&t.ch&&i.push("ch"),"incr"in t&&t.incr&&i.push("incr"),"lt"in t&&t.lt?i.push("lt"):"gt"in t&&t.gt&&i.push("gt"),"score"in t&&"member"in t&&i.push(t.score,t.member),i.push(...s.flatMap(({score:e,member:t})=>[e,t])),super(i,n)}},iS=class extends tX{constructor(e,t){super(["zcard",...e],t)}},ik=class extends tX{constructor(e,t){super(["zcount",...e],t)}},iT=class extends tX{constructor(e,t){super(["zincrby",...e],t)}},iA=class extends tX{constructor([e,t,s,n],i){const r=["zinterstore",e,t];Array.isArray(s)?r.push(...s):r.push(s),n&&("weights"in n&&n.weights?r.push("weights",...n.weights):"weight"in n&&"number"==typeof n.weight&&r.push("weights",n.weight),"aggregate"in n&&r.push("aggregate",n.aggregate)),super(r,i)}},i_=class extends tX{constructor(e,t){super(["zlexcount",...e],t)}},iC=class extends tX{constructor([e,t],s){const n=["zpopmax",e];"number"==typeof t&&n.push(t),super(n,s)}},iI=class extends tX{constructor([e,t],s){const n=["zpopmin",e];"number"==typeof t&&n.push(t),super(n,s)}},iP=class extends tX{constructor([e,t,s,n],i){const r=["zrange",e,t,s];n?.byScore&&r.push("byscore"),n?.byLex&&r.push("bylex"),n?.rev&&r.push("rev"),n?.count!==void 0&&void 0!==n.offset&&r.push("limit",n.offset,n.count),n?.withScores&&r.push("withscores"),super(r,i)}},iN=class extends tX{constructor(e,t){super(["zrank",...e],t)}},iM=class extends tX{constructor(e,t){super(["zrem",...e],t)}},iD=class extends tX{constructor(e,t){super(["zremrangebylex",...e],t)}},iL=class extends tX{constructor(e,t){super(["zremrangebyrank",...e],t)}},iU=class extends tX{constructor(e,t){super(["zremrangebyscore",...e],t)}},ij=class extends tX{constructor(e,t){super(["zrevrank",...e],t)}},i$=class extends tX{constructor([e,t,s],n){const i=["zscan",e,t];s?.match&&i.push("match",s.match),"number"==typeof s?.count&&i.push("count",s.count),super(i,{deserialize:tK,...n})}},iz=class extends tX{constructor(e,t){super(["zscore",...e],t)}},iW=class extends tX{constructor([e,t,s],n){const i=["zunion",e];Array.isArray(t)?i.push(...t):i.push(t),s&&("weights"in s&&s.weights?i.push("weights",...s.weights):"weight"in s&&"number"==typeof s.weight&&i.push("weights",s.weight),"aggregate"in s&&i.push("aggregate",s.aggregate),s.withScores&&i.push("withscores")),super(i,n)}},iq=class extends tX{constructor([e,t,s,n],i){const r=["zunionstore",e,t];Array.isArray(s)?r.push(...s):r.push(s),n&&("weights"in n&&n.weights?r.push("weights",...n.weights):"weight"in n&&"number"==typeof n.weight&&r.push("weights",n.weight),"aggregate"in n&&r.push("aggregate",n.aggregate)),super(r,i)}},iB=class extends tX{constructor(e,t){super(["zdiffstore",...e],t)}},iK=class extends tX{constructor(e,t){const[s,n]=e;super(["zmscore",s,...n],t)}},iF=class{client;commands;commandOptions;multiExec;constructor(e){if(this.client=e.client,this.commands=[],this.commandOptions=e.commandOptions,this.multiExec=e.multiExec??!1,this.commandOptions?.latencyLogging){const e=this.exec.bind(this);this.exec=async t=>{let s=performance.now(),n=await (t?e(t):e()),i=(performance.now()-s).toFixed(2);return console.log(`Latency for \x1b[38;2;19;185;39m${this.multiExec?["MULTI-EXEC"]:["PIPELINE"].toString().toUpperCase()}\x1b[0m: \x1b[38;2;0;255;255m${i} ms\x1b[0m`),n}}}exec=async e=>{if(0===this.commands.length)throw Error("Pipeline is empty");let t=this.multiExec?["multi-exec"]:["pipeline"],s=await this.client.request({path:t,body:Object.values(this.commands).map(e=>e.command)});return e?.keepErrors?s.map(({error:e,result:t},s)=>({error:e,result:this.commands[s].deserialize(t)})):s.map(({error:e,result:t},s)=>{if(e)throw new tW(`Command ${s+1} [ ${this.commands[s].command[0]} ] failed: ${e}`);return this.commands[s].deserialize(t)})};length(){return this.commands.length}chain(e){return this.commands.push(e),this}append=(...e)=>this.chain(new tQ(e,this.commandOptions));bitcount=(...e)=>this.chain(new t0(e,this.commandOptions));bitfield=(...e)=>new t1(e,this.client,this.commandOptions,this.chain.bind(this));bitop=(e,t,s,...n)=>this.chain(new t2([e,t,s,...n],this.commandOptions));bitpos=(...e)=>this.chain(new t3(e,this.commandOptions));copy=(...e)=>this.chain(new t4(e,this.commandOptions));zdiffstore=(...e)=>this.chain(new iB(e,this.commandOptions));dbsize=()=>this.chain(new t5(this.commandOptions));decr=(...e)=>this.chain(new t6(e,this.commandOptions));decrby=(...e)=>this.chain(new t8(e,this.commandOptions));del=(...e)=>this.chain(new t9(e,this.commandOptions));echo=(...e)=>this.chain(new t7(e,this.commandOptions));evalRo=(...e)=>this.chain(new se(e,this.commandOptions));eval=(...e)=>this.chain(new st(e,this.commandOptions));evalshaRo=(...e)=>this.chain(new ss(e,this.commandOptions));evalsha=(...e)=>this.chain(new sn(e,this.commandOptions));exists=(...e)=>this.chain(new sr(e,this.commandOptions));expire=(...e)=>this.chain(new so(e,this.commandOptions));expireat=(...e)=>this.chain(new sa(e,this.commandOptions));flushall=e=>this.chain(new sc(e,this.commandOptions));flushdb=(...e)=>this.chain(new sl(e,this.commandOptions));geoadd=(...e)=>this.chain(new sh(e,this.commandOptions));geodist=(...e)=>this.chain(new su(e,this.commandOptions));geopos=(...e)=>this.chain(new sd(e,this.commandOptions));geohash=(...e)=>this.chain(new sp(e,this.commandOptions));geosearch=(...e)=>this.chain(new sm(e,this.commandOptions));geosearchstore=(...e)=>this.chain(new sf(e,this.commandOptions));get=(...e)=>this.chain(new sw(e,this.commandOptions));getbit=(...e)=>this.chain(new sg(e,this.commandOptions));getdel=(...e)=>this.chain(new sy(e,this.commandOptions));getex=(...e)=>this.chain(new sx(e,this.commandOptions));getrange=(...e)=>this.chain(new sb(e,this.commandOptions));getset=(e,t)=>this.chain(new sv([e,t],this.commandOptions));hdel=(...e)=>this.chain(new sO(e,this.commandOptions));hexists=(...e)=>this.chain(new sE(e,this.commandOptions));hexpire=(...e)=>this.chain(new sR(e,this.commandOptions));hexpireat=(...e)=>this.chain(new sS(e,this.commandOptions));hexpiretime=(...e)=>this.chain(new sk(e,this.commandOptions));httl=(...e)=>this.chain(new sK(e,this.commandOptions));hpexpire=(...e)=>this.chain(new sA(e,this.commandOptions));hpexpireat=(...e)=>this.chain(new s_(e,this.commandOptions));hpexpiretime=(...e)=>this.chain(new sC(e,this.commandOptions));hpttl=(...e)=>this.chain(new sI(e,this.commandOptions));hpersist=(...e)=>this.chain(new sT(e,this.commandOptions));hget=(...e)=>this.chain(new sP(e,this.commandOptions));hgetall=(...e)=>this.chain(new sN(e,this.commandOptions));hincrby=(...e)=>this.chain(new sM(e,this.commandOptions));hincrbyfloat=(...e)=>this.chain(new sD(e,this.commandOptions));hkeys=(...e)=>this.chain(new sL(e,this.commandOptions));hlen=(...e)=>this.chain(new sU(e,this.commandOptions));hmget=(...e)=>this.chain(new sj(e,this.commandOptions));hmset=(e,t)=>this.chain(new s$([e,t],this.commandOptions));hrandfield=(e,t,s)=>this.chain(new tZ([e,t,s],this.commandOptions));hscan=(...e)=>this.chain(new sz(e,this.commandOptions));hset=(e,t)=>this.chain(new sW([e,t],this.commandOptions));hsetnx=(e,t,s)=>this.chain(new sq([e,t,s],this.commandOptions));hstrlen=(...e)=>this.chain(new sB(e,this.commandOptions));hvals=(...e)=>this.chain(new sF(e,this.commandOptions));incr=(...e)=>this.chain(new sG(e,this.commandOptions));incrby=(...e)=>this.chain(new sH(e,this.commandOptions));incrbyfloat=(...e)=>this.chain(new sV(e,this.commandOptions));keys=(...e)=>this.chain(new nc(e,this.commandOptions));lindex=(...e)=>this.chain(new nl(e,this.commandOptions));linsert=(e,t,s,n)=>this.chain(new nh([e,t,s,n],this.commandOptions));llen=(...e)=>this.chain(new nu(e,this.commandOptions));lmove=(...e)=>this.chain(new np(e,this.commandOptions));lpop=(...e)=>this.chain(new nm(e,this.commandOptions));lmpop=(...e)=>this.chain(new nd(e,this.commandOptions));lpos=(...e)=>this.chain(new nf(e,this.commandOptions));lpush=(e,...t)=>this.chain(new nw([e,...t],this.commandOptions));lpushx=(e,...t)=>this.chain(new ng([e,...t],this.commandOptions));lrange=(...e)=>this.chain(new ny(e,this.commandOptions));lrem=(e,t,s)=>this.chain(new nx([e,t,s],this.commandOptions));lset=(e,t,s)=>this.chain(new nb([e,t,s],this.commandOptions));ltrim=(...e)=>this.chain(new nv(e,this.commandOptions));mget=(...e)=>this.chain(new nO(e,this.commandOptions));mset=e=>this.chain(new nE([e],this.commandOptions));msetnx=e=>this.chain(new nR([e],this.commandOptions));persist=(...e)=>this.chain(new nS(e,this.commandOptions));pexpire=(...e)=>this.chain(new nk(e,this.commandOptions));pexpireat=(...e)=>this.chain(new nT(e,this.commandOptions));pfadd=(...e)=>this.chain(new nA(e,this.commandOptions));pfcount=(...e)=>this.chain(new n_(e,this.commandOptions));pfmerge=(...e)=>this.chain(new nC(e,this.commandOptions));ping=e=>this.chain(new nI(e,this.commandOptions));psetex=(e,t,s)=>this.chain(new nP([e,t,s],this.commandOptions));pttl=(...e)=>this.chain(new nN(e,this.commandOptions));publish=(...e)=>this.chain(new nM(e,this.commandOptions));randomkey=()=>this.chain(new nD(this.commandOptions));rename=(...e)=>this.chain(new nL(e,this.commandOptions));renamenx=(...e)=>this.chain(new nU(e,this.commandOptions));rpop=(...e)=>this.chain(new nj(e,this.commandOptions));rpush=(e,...t)=>this.chain(new n$([e,...t],this.commandOptions));rpushx=(e,...t)=>this.chain(new nz([e,...t],this.commandOptions));sadd=(e,t,...s)=>this.chain(new nW([e,t,...s],this.commandOptions));scan=(...e)=>this.chain(new nq(e,this.commandOptions));scard=(...e)=>this.chain(new nB(e,this.commandOptions));scriptExists=(...e)=>this.chain(new nK(e,this.commandOptions));scriptFlush=(...e)=>this.chain(new nF(e,this.commandOptions));scriptLoad=(...e)=>this.chain(new nG(e,this.commandOptions));sdiff=(...e)=>this.chain(new nH(e,this.commandOptions));sdiffstore=(...e)=>this.chain(new nV(e,this.commandOptions));set=(e,t,s)=>this.chain(new nJ([e,t,s],this.commandOptions));setbit=(...e)=>this.chain(new nY(e,this.commandOptions));setex=(e,t,s)=>this.chain(new nX([e,t,s],this.commandOptions));setnx=(e,t)=>this.chain(new nZ([e,t],this.commandOptions));setrange=(...e)=>this.chain(new nQ(e,this.commandOptions));sinter=(...e)=>this.chain(new n0(e,this.commandOptions));sinterstore=(...e)=>this.chain(new n1(e,this.commandOptions));sismember=(e,t)=>this.chain(new n2([e,t],this.commandOptions));smembers=(...e)=>this.chain(new n3(e,this.commandOptions));smismember=(e,t)=>this.chain(new n4([e,t],this.commandOptions));smove=(e,t,s)=>this.chain(new n5([e,t,s],this.commandOptions));spop=(...e)=>this.chain(new n6(e,this.commandOptions));srandmember=(...e)=>this.chain(new n8(e,this.commandOptions));srem=(e,...t)=>this.chain(new n9([e,...t],this.commandOptions));sscan=(...e)=>this.chain(new n7(e,this.commandOptions));strlen=(...e)=>this.chain(new ie(e,this.commandOptions));sunion=(...e)=>this.chain(new it(e,this.commandOptions));sunionstore=(...e)=>this.chain(new is(e,this.commandOptions));time=()=>this.chain(new ii(this.commandOptions));touch=(...e)=>this.chain(new ir(e,this.commandOptions));ttl=(...e)=>this.chain(new io(e,this.commandOptions));type=(...e)=>this.chain(new ia(e,this.commandOptions));unlink=(...e)=>this.chain(new ic(e,this.commandOptions));zadd=(...e)=>("score"in e[1],this.chain(new iR([e[0],e[1],...e.slice(2)],this.commandOptions)));xadd=(...e)=>this.chain(new ih(e,this.commandOptions));xack=(...e)=>this.chain(new il(e,this.commandOptions));xdel=(...e)=>this.chain(new id(e,this.commandOptions));xgroup=(...e)=>this.chain(new im(e,this.commandOptions));xread=(...e)=>this.chain(new ib(e,this.commandOptions));xreadgroup=(...e)=>this.chain(new iv(e,this.commandOptions));xinfo=(...e)=>this.chain(new iw(e,this.commandOptions));xlen=(...e)=>this.chain(new ig(e,this.commandOptions));xpending=(...e)=>this.chain(new iy(e,this.commandOptions));xclaim=(...e)=>this.chain(new ip(e,this.commandOptions));xautoclaim=(...e)=>this.chain(new iu(e,this.commandOptions));xtrim=(...e)=>this.chain(new iE(e,this.commandOptions));xrange=(...e)=>this.chain(new ix(e,this.commandOptions));xrevrange=(...e)=>this.chain(new iO(e,this.commandOptions));zcard=(...e)=>this.chain(new iS(e,this.commandOptions));zcount=(...e)=>this.chain(new ik(e,this.commandOptions));zincrby=(e,t,s)=>this.chain(new iT([e,t,s],this.commandOptions));zinterstore=(...e)=>this.chain(new iA(e,this.commandOptions));zlexcount=(...e)=>this.chain(new i_(e,this.commandOptions));zmscore=(...e)=>this.chain(new iK(e,this.commandOptions));zpopmax=(...e)=>this.chain(new iC(e,this.commandOptions));zpopmin=(...e)=>this.chain(new iI(e,this.commandOptions));zrange=(...e)=>this.chain(new iP(e,this.commandOptions));zrank=(e,t)=>this.chain(new iN([e,t],this.commandOptions));zrem=(e,...t)=>this.chain(new iM([e,...t],this.commandOptions));zremrangebylex=(...e)=>this.chain(new iD(e,this.commandOptions));zremrangebyrank=(...e)=>this.chain(new iL(e,this.commandOptions));zremrangebyscore=(...e)=>this.chain(new iU(e,this.commandOptions));zrevrank=(e,t)=>this.chain(new ij([e,t],this.commandOptions));zscan=(...e)=>this.chain(new i$(e,this.commandOptions));zscore=(e,t)=>this.chain(new iz([e,t],this.commandOptions));zunionstore=(...e)=>this.chain(new iq(e,this.commandOptions));zunion=(...e)=>this.chain(new iW(e,this.commandOptions));get json(){return{arrappend:(...e)=>this.chain(new sJ(e,this.commandOptions)),arrindex:(...e)=>this.chain(new sY(e,this.commandOptions)),arrinsert:(...e)=>this.chain(new sX(e,this.commandOptions)),arrlen:(...e)=>this.chain(new sZ(e,this.commandOptions)),arrpop:(...e)=>this.chain(new sQ(e,this.commandOptions)),arrtrim:(...e)=>this.chain(new s0(e,this.commandOptions)),clear:(...e)=>this.chain(new s1(e,this.commandOptions)),del:(...e)=>this.chain(new s2(e,this.commandOptions)),forget:(...e)=>this.chain(new s3(e,this.commandOptions)),get:(...e)=>this.chain(new s4(e,this.commandOptions)),merge:(...e)=>this.chain(new s5(e,this.commandOptions)),mget:(...e)=>this.chain(new s6(e,this.commandOptions)),mset:(...e)=>this.chain(new s8(e,this.commandOptions)),numincrby:(...e)=>this.chain(new s9(e,this.commandOptions)),nummultby:(...e)=>this.chain(new s7(e,this.commandOptions)),objkeys:(...e)=>this.chain(new ne(e,this.commandOptions)),objlen:(...e)=>this.chain(new nt(e,this.commandOptions)),resp:(...e)=>this.chain(new ns(e,this.commandOptions)),set:(...e)=>this.chain(new nn(e,this.commandOptions)),strappend:(...e)=>this.chain(new ni(e,this.commandOptions)),strlen:(...e)=>this.chain(new nr(e,this.commandOptions)),toggle:(...e)=>this.chain(new no(e,this.commandOptions)),type:(...e)=>this.chain(new na(e,this.commandOptions))}}},iG=new Set(["scan","keys","flushdb","flushall","dbsize","hscan","hgetall","hkeys","lrange","sscan","smembers","xrange","xrevrange","zscan","zrange","exec"]),iH=class{pipelinePromises=new WeakMap;activePipeline=null;indexInCurrentPipeline=0;redis;pipeline;pipelineCounter=0;constructor(e){this.redis=e,this.pipeline=e.pipeline()}async withAutoPipeline(e){let t=this.activePipeline??this.redis.pipeline();this.activePipeline||(this.activePipeline=t,this.indexInCurrentPipeline=0);let s=this.indexInCurrentPipeline++;e(t);let n=this.deferExecution().then(()=>{if(!this.pipelinePromises.has(t)){let e=t.exec({keepErrors:!0});this.pipelineCounter+=1,this.pipelinePromises.set(t,e),this.activePipeline=null}return this.pipelinePromises.get(t)}),i=(await n)[s];if(i.error)throw new tW(`Command failed: ${i.error}`);return i.result}async deferExecution(){await Promise.resolve(),await Promise.resolve()}},iV=class extends tX{constructor(e,t){super([],{...t,headers:{Accept:"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"},path:["psubscribe",...e],streamOptions:{isStreaming:!0,onMessage:t?.streamOptions?.onMessage,signal:t?.streamOptions?.signal}})}},iJ=class extends EventTarget{subscriptions;client;listeners;constructor(e,t,s=!1){for(const n of(super(),this.client=e,this.subscriptions=new Map,this.listeners=new Map,t))s?this.subscribeToPattern(n):this.subscribeToChannel(n)}subscribeToChannel(e){let t=new AbortController,s=new iY([e],{streamOptions:{signal:t.signal,onMessage:e=>this.handleMessage(e,!1)}});s.exec(this.client).catch(e=>{"AbortError"!==e.name&&this.dispatchToListeners("error",e)}),this.subscriptions.set(e,{command:s,controller:t,isPattern:!1})}subscribeToPattern(e){let t=new AbortController,s=new iV([e],{streamOptions:{signal:t.signal,onMessage:e=>this.handleMessage(e,!0)}});s.exec(this.client).catch(e=>{"AbortError"!==e.name&&this.dispatchToListeners("error",e)}),this.subscriptions.set(e,{command:s,controller:t,isPattern:!0})}handleMessage(e,t){let s=e.replace(/^data:\s*/,""),n=s.indexOf(","),i=s.indexOf(",",n+1),r=t?s.indexOf(",",i+1):-1;if(-1!==n&&-1!==i){let e=s.slice(0,n);if(t&&"pmessage"===e&&-1!==r){let e=s.slice(n+1,i),t=s.slice(i+1,r),o=s.slice(r+1);try{let s=JSON.parse(o);this.dispatchToListeners("pmessage",{pattern:e,channel:t,message:s}),this.dispatchToListeners(`pmessage:${e}`,{pattern:e,channel:t,message:s})}catch(e){this.dispatchToListeners("error",Error(`Failed to parse message: ${e}`))}}else{let t=s.slice(n+1,i),r=s.slice(i+1);try{if("subscribe"===e||"psubscribe"===e||"unsubscribe"===e||"punsubscribe"===e){let t=Number.parseInt(r);this.dispatchToListeners(e,t)}else{let s=JSON.parse(r);this.dispatchToListeners(e,{channel:t,message:s}),this.dispatchToListeners(`${e}:${t}`,{channel:t,message:s})}}catch(e){this.dispatchToListeners("error",Error(`Failed to parse message: ${e}`))}}}}dispatchToListeners(e,t){let s=this.listeners.get(e);if(s)for(let e of s)e(t)}on(e,t){this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e)?.add(t)}removeAllListeners(){this.listeners.clear()}async unsubscribe(e){if(e)for(let t of e){let e=this.subscriptions.get(t);if(e){try{e.controller.abort()}catch{}this.subscriptions.delete(t)}}else{for(let e of this.subscriptions.values())try{e.controller.abort()}catch{}this.subscriptions.clear(),this.removeAllListeners()}}getSubscribedChannels(){return[...this.subscriptions.keys()]}},iY=class extends tX{constructor(e,t){super([],{...t,headers:{Accept:"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"},path:["subscribe",...e],streamOptions:{isStreaming:!0,onMessage:t?.streamOptions?.onMessage,signal:t?.streamOptions?.signal}})}},iX=class{script;sha1;redis;constructor(e,t){this.redis=e,this.script=t,this.sha1="",this.init(t)}async init(e){this.sha1||(this.sha1=await this.digest(e))}async eval(e,t){return await this.init(this.script),await this.redis.eval(this.script,e,t)}async evalsha(e,t){return await this.init(this.script),await this.redis.evalsha(this.sha1,e,t)}async exec(e,t){return await this.init(this.script),await this.redis.evalsha(this.sha1,e,t).catch(async s=>{if(s instanceof Error&&s.message.toLowerCase().includes("noscript"))return await this.redis.eval(this.script,e,t);throw s})}async digest(e){let t=new TextEncoder().encode(e);return[...new Uint8Array(await tL.digest("SHA-1",t))].map(e=>e.toString(16).padStart(2,"0")).join("")}},iZ=class{script;sha1;redis;constructor(e,t){this.redis=e,this.sha1="",this.script=t,this.init(t)}async init(e){this.sha1||(this.sha1=await this.digest(e))}async evalRo(e,t){return await this.init(this.script),await this.redis.evalRo(this.script,e,t)}async evalshaRo(e,t){return await this.init(this.script),await this.redis.evalshaRo(this.sha1,e,t)}async exec(e,t){return await this.init(this.script),await this.redis.evalshaRo(this.sha1,e,t).catch(async s=>{if(s instanceof Error&&s.message.toLowerCase().includes("noscript"))return await this.redis.evalRo(this.script,e,t);throw s})}async digest(e){let t=new TextEncoder().encode(e);return[...new Uint8Array(await tL.digest("SHA-1",t))].map(e=>e.toString(16).padStart(2,"0")).join("")}},iQ=class{client;opts;enableTelemetry;enableAutoPipelining;constructor(e,t){this.client=e,this.opts=t,this.enableTelemetry=t?.enableTelemetry??!0,t?.readYourWrites===!1&&(this.client.readYourWrites=!1),this.enableAutoPipelining=t?.enableAutoPipelining??!0}get readYourWritesSyncToken(){return this.client.upstashSyncToken}set readYourWritesSyncToken(e){this.client.upstashSyncToken=e}get json(){return{arrappend:(...e)=>new sJ(e,this.opts).exec(this.client),arrindex:(...e)=>new sY(e,this.opts).exec(this.client),arrinsert:(...e)=>new sX(e,this.opts).exec(this.client),arrlen:(...e)=>new sZ(e,this.opts).exec(this.client),arrpop:(...e)=>new sQ(e,this.opts).exec(this.client),arrtrim:(...e)=>new s0(e,this.opts).exec(this.client),clear:(...e)=>new s1(e,this.opts).exec(this.client),del:(...e)=>new s2(e,this.opts).exec(this.client),forget:(...e)=>new s3(e,this.opts).exec(this.client),get:(...e)=>new s4(e,this.opts).exec(this.client),merge:(...e)=>new s5(e,this.opts).exec(this.client),mget:(...e)=>new s6(e,this.opts).exec(this.client),mset:(...e)=>new s8(e,this.opts).exec(this.client),numincrby:(...e)=>new s9(e,this.opts).exec(this.client),nummultby:(...e)=>new s7(e,this.opts).exec(this.client),objkeys:(...e)=>new ne(e,this.opts).exec(this.client),objlen:(...e)=>new nt(e,this.opts).exec(this.client),resp:(...e)=>new ns(e,this.opts).exec(this.client),set:(...e)=>new nn(e,this.opts).exec(this.client),strappend:(...e)=>new ni(e,this.opts).exec(this.client),strlen:(...e)=>new nr(e,this.opts).exec(this.client),toggle:(...e)=>new no(e,this.opts).exec(this.client),type:(...e)=>new na(e,this.opts).exec(this.client)}}use=e=>{let t=this.client.request.bind(this.client);this.client.request=s=>e(s,t)};addTelemetry=e=>{if(this.enableTelemetry)try{this.client.mergeTelemetry(e)}catch{}};createScript(e,t){return t?.readonly?new iZ(this,e):new iX(this,e)}pipeline=()=>new iF({client:this.client,commandOptions:this.opts,multiExec:!1});autoPipeline=()=>(function e(t,s){return t.autoPipelineExecutor||(t.autoPipelineExecutor=new iH(t)),new Proxy(t,{get:(t,n)=>{if("pipelineCounter"===n)return t.autoPipelineExecutor.pipelineCounter;if("json"===n)return e(t,!0);let i=n in t&&!(n in t.autoPipelineExecutor.pipeline),r=iG.has(n);return i||r?t[n]:(s?"function"==typeof t.autoPipelineExecutor.pipeline.json[n]:"function"==typeof t.autoPipelineExecutor.pipeline[n])?(...e)=>t.autoPipelineExecutor.withAutoPipeline(t=>{s?t.json[n](...e):t[n](...e)}):t.autoPipelineExecutor.pipeline[n]}})})(this);multi=()=>new iF({client:this.client,commandOptions:this.opts,multiExec:!0});bitfield=(...e)=>new t1(e,this.client,this.opts);append=(...e)=>new tQ(e,this.opts).exec(this.client);bitcount=(...e)=>new t0(e,this.opts).exec(this.client);bitop=(e,t,s,...n)=>new t2([e,t,s,...n],this.opts).exec(this.client);bitpos=(...e)=>new t3(e,this.opts).exec(this.client);copy=(...e)=>new t4(e,this.opts).exec(this.client);dbsize=()=>new t5(this.opts).exec(this.client);decr=(...e)=>new t6(e,this.opts).exec(this.client);decrby=(...e)=>new t8(e,this.opts).exec(this.client);del=(...e)=>new t9(e,this.opts).exec(this.client);echo=(...e)=>new t7(e,this.opts).exec(this.client);evalRo=(...e)=>new se(e,this.opts).exec(this.client);eval=(...e)=>new st(e,this.opts).exec(this.client);evalshaRo=(...e)=>new ss(e,this.opts).exec(this.client);evalsha=(...e)=>new sn(e,this.opts).exec(this.client);exec=e=>new si(e,this.opts).exec(this.client);exists=(...e)=>new sr(e,this.opts).exec(this.client);expire=(...e)=>new so(e,this.opts).exec(this.client);expireat=(...e)=>new sa(e,this.opts).exec(this.client);flushall=e=>new sc(e,this.opts).exec(this.client);flushdb=(...e)=>new sl(e,this.opts).exec(this.client);geoadd=(...e)=>new sh(e,this.opts).exec(this.client);geopos=(...e)=>new sd(e,this.opts).exec(this.client);geodist=(...e)=>new su(e,this.opts).exec(this.client);geohash=(...e)=>new sp(e,this.opts).exec(this.client);geosearch=(...e)=>new sm(e,this.opts).exec(this.client);geosearchstore=(...e)=>new sf(e,this.opts).exec(this.client);get=(...e)=>new sw(e,this.opts).exec(this.client);getbit=(...e)=>new sg(e,this.opts).exec(this.client);getdel=(...e)=>new sy(e,this.opts).exec(this.client);getex=(...e)=>new sx(e,this.opts).exec(this.client);getrange=(...e)=>new sb(e,this.opts).exec(this.client);getset=(e,t)=>new sv([e,t],this.opts).exec(this.client);hdel=(...e)=>new sO(e,this.opts).exec(this.client);hexists=(...e)=>new sE(e,this.opts).exec(this.client);hexpire=(...e)=>new sR(e,this.opts).exec(this.client);hexpireat=(...e)=>new sS(e,this.opts).exec(this.client);hexpiretime=(...e)=>new sk(e,this.opts).exec(this.client);httl=(...e)=>new sK(e,this.opts).exec(this.client);hpexpire=(...e)=>new sA(e,this.opts).exec(this.client);hpexpireat=(...e)=>new s_(e,this.opts).exec(this.client);hpexpiretime=(...e)=>new sC(e,this.opts).exec(this.client);hpttl=(...e)=>new sI(e,this.opts).exec(this.client);hpersist=(...e)=>new sT(e,this.opts).exec(this.client);hget=(...e)=>new sP(e,this.opts).exec(this.client);hgetall=(...e)=>new sN(e,this.opts).exec(this.client);hincrby=(...e)=>new sM(e,this.opts).exec(this.client);hincrbyfloat=(...e)=>new sD(e,this.opts).exec(this.client);hkeys=(...e)=>new sL(e,this.opts).exec(this.client);hlen=(...e)=>new sU(e,this.opts).exec(this.client);hmget=(...e)=>new sj(e,this.opts).exec(this.client);hmset=(e,t)=>new s$([e,t],this.opts).exec(this.client);hrandfield=(e,t,s)=>new tZ([e,t,s],this.opts).exec(this.client);hscan=(...e)=>new sz(e,this.opts).exec(this.client);hset=(e,t)=>new sW([e,t],this.opts).exec(this.client);hsetnx=(e,t,s)=>new sq([e,t,s],this.opts).exec(this.client);hstrlen=(...e)=>new sB(e,this.opts).exec(this.client);hvals=(...e)=>new sF(e,this.opts).exec(this.client);incr=(...e)=>new sG(e,this.opts).exec(this.client);incrby=(...e)=>new sH(e,this.opts).exec(this.client);incrbyfloat=(...e)=>new sV(e,this.opts).exec(this.client);keys=(...e)=>new nc(e,this.opts).exec(this.client);lindex=(...e)=>new nl(e,this.opts).exec(this.client);linsert=(e,t,s,n)=>new nh([e,t,s,n],this.opts).exec(this.client);llen=(...e)=>new nu(e,this.opts).exec(this.client);lmove=(...e)=>new np(e,this.opts).exec(this.client);lpop=(...e)=>new nm(e,this.opts).exec(this.client);lmpop=(...e)=>new nd(e,this.opts).exec(this.client);lpos=(...e)=>new nf(e,this.opts).exec(this.client);lpush=(e,...t)=>new nw([e,...t],this.opts).exec(this.client);lpushx=(e,...t)=>new ng([e,...t],this.opts).exec(this.client);lrange=(...e)=>new ny(e,this.opts).exec(this.client);lrem=(e,t,s)=>new nx([e,t,s],this.opts).exec(this.client);lset=(e,t,s)=>new nb([e,t,s],this.opts).exec(this.client);ltrim=(...e)=>new nv(e,this.opts).exec(this.client);mget=(...e)=>new nO(e,this.opts).exec(this.client);mset=e=>new nE([e],this.opts).exec(this.client);msetnx=e=>new nR([e],this.opts).exec(this.client);persist=(...e)=>new nS(e,this.opts).exec(this.client);pexpire=(...e)=>new nk(e,this.opts).exec(this.client);pexpireat=(...e)=>new nT(e,this.opts).exec(this.client);pfadd=(...e)=>new nA(e,this.opts).exec(this.client);pfcount=(...e)=>new n_(e,this.opts).exec(this.client);pfmerge=(...e)=>new nC(e,this.opts).exec(this.client);ping=e=>new nI(e,this.opts).exec(this.client);psetex=(e,t,s)=>new nP([e,t,s],this.opts).exec(this.client);psubscribe=e=>{let t=Array.isArray(e)?e:[e];return new iJ(this.client,t,!0)};pttl=(...e)=>new nN(e,this.opts).exec(this.client);publish=(...e)=>new nM(e,this.opts).exec(this.client);randomkey=()=>new nD().exec(this.client);rename=(...e)=>new nL(e,this.opts).exec(this.client);renamenx=(...e)=>new nU(e,this.opts).exec(this.client);rpop=(...e)=>new nj(e,this.opts).exec(this.client);rpush=(e,...t)=>new n$([e,...t],this.opts).exec(this.client);rpushx=(e,...t)=>new nz([e,...t],this.opts).exec(this.client);sadd=(e,t,...s)=>new nW([e,t,...s],this.opts).exec(this.client);scan(e,t){return new nq([e,t],this.opts).exec(this.client)}scard=(...e)=>new nB(e,this.opts).exec(this.client);scriptExists=(...e)=>new nK(e,this.opts).exec(this.client);scriptFlush=(...e)=>new nF(e,this.opts).exec(this.client);scriptLoad=(...e)=>new nG(e,this.opts).exec(this.client);sdiff=(...e)=>new nH(e,this.opts).exec(this.client);sdiffstore=(...e)=>new nV(e,this.opts).exec(this.client);set=(e,t,s)=>new nJ([e,t,s],this.opts).exec(this.client);setbit=(...e)=>new nY(e,this.opts).exec(this.client);setex=(e,t,s)=>new nX([e,t,s],this.opts).exec(this.client);setnx=(e,t)=>new nZ([e,t],this.opts).exec(this.client);setrange=(...e)=>new nQ(e,this.opts).exec(this.client);sinter=(...e)=>new n0(e,this.opts).exec(this.client);sinterstore=(...e)=>new n1(e,this.opts).exec(this.client);sismember=(e,t)=>new n2([e,t],this.opts).exec(this.client);smismember=(e,t)=>new n4([e,t],this.opts).exec(this.client);smembers=(...e)=>new n3(e,this.opts).exec(this.client);smove=(e,t,s)=>new n5([e,t,s],this.opts).exec(this.client);spop=(...e)=>new n6(e,this.opts).exec(this.client);srandmember=(...e)=>new n8(e,this.opts).exec(this.client);srem=(e,...t)=>new n9([e,...t],this.opts).exec(this.client);sscan=(...e)=>new n7(e,this.opts).exec(this.client);strlen=(...e)=>new ie(e,this.opts).exec(this.client);subscribe=e=>{let t=Array.isArray(e)?e:[e];return new iJ(this.client,t)};sunion=(...e)=>new it(e,this.opts).exec(this.client);sunionstore=(...e)=>new is(e,this.opts).exec(this.client);time=()=>new ii().exec(this.client);touch=(...e)=>new ir(e,this.opts).exec(this.client);ttl=(...e)=>new io(e,this.opts).exec(this.client);type=(...e)=>new ia(e,this.opts).exec(this.client);unlink=(...e)=>new ic(e,this.opts).exec(this.client);xadd=(...e)=>new ih(e,this.opts).exec(this.client);xack=(...e)=>new il(e,this.opts).exec(this.client);xdel=(...e)=>new id(e,this.opts).exec(this.client);xgroup=(...e)=>new im(e,this.opts).exec(this.client);xread=(...e)=>new ib(e,this.opts).exec(this.client);xreadgroup=(...e)=>new iv(e,this.opts).exec(this.client);xinfo=(...e)=>new iw(e,this.opts).exec(this.client);xlen=(...e)=>new ig(e,this.opts).exec(this.client);xpending=(...e)=>new iy(e,this.opts).exec(this.client);xclaim=(...e)=>new ip(e,this.opts).exec(this.client);xautoclaim=(...e)=>new iu(e,this.opts).exec(this.client);xtrim=(...e)=>new iE(e,this.opts).exec(this.client);xrange=(...e)=>new ix(e,this.opts).exec(this.client);xrevrange=(...e)=>new iO(e,this.opts).exec(this.client);zadd=(...e)=>("score"in e[1],new iR([e[0],e[1],...e.slice(2)],this.opts).exec(this.client));zcard=(...e)=>new iS(e,this.opts).exec(this.client);zcount=(...e)=>new ik(e,this.opts).exec(this.client);zdiffstore=(...e)=>new iB(e,this.opts).exec(this.client);zincrby=(e,t,s)=>new iT([e,t,s],this.opts).exec(this.client);zinterstore=(...e)=>new iA(e,this.opts).exec(this.client);zlexcount=(...e)=>new i_(e,this.opts).exec(this.client);zmscore=(...e)=>new iK(e,this.opts).exec(this.client);zpopmax=(...e)=>new iC(e,this.opts).exec(this.client);zpopmin=(...e)=>new iI(e,this.opts).exec(this.client);zrange=(...e)=>new iP(e,this.opts).exec(this.client);zrank=(e,t)=>new iN([e,t],this.opts).exec(this.client);zrem=(e,...t)=>new iM([e,...t],this.opts).exec(this.client);zremrangebylex=(...e)=>new iD(e,this.opts).exec(this.client);zremrangebyrank=(...e)=>new iL(e,this.opts).exec(this.client);zremrangebyscore=(...e)=>new iU(e,this.opts).exec(this.client);zrevrank=(e,t)=>new ij([e,t],this.opts).exec(this.client);zscan=(...e)=>new i$(e,this.opts).exec(this.client);zscore=(e,t)=>new iz([e,t],this.opts).exec(this.client);zunion=(...e)=>new iW(e,this.opts).exec(this.client);zunionstore=(...e)=>new iq(e,this.opts).exec(this.client)};"undefined"==typeof atob&&(e.g.atob=e=>Buffer.from(e,"base64").toString("utf8"));var i0=class e extends iQ{constructor(e){if("request"in e)return void super(e);if(e.url?(e.url.startsWith(" ")||e.url.endsWith(" ")||/\r|\n/.test(e.url))&&console.warn("[Upstash Redis] The redis url contains whitespace or newline, which can cause errors!"):console.warn("[Upstash Redis] The 'url' property is missing or undefined in your Redis config."),e.token?(e.token.startsWith(" ")||e.token.endsWith(" ")||/\r|\n/.test(e.token))&&console.warn("[Upstash Redis] The redis token contains whitespace or newline, which can cause errors!"):console.warn("[Upstash Redis] The 'token' property is missing or undefined in your Redis config."),super(new tG({baseUrl:e.url,retry:e.retry,headers:{authorization:`Bearer ${e.token}`},agent:e.agent,responseEncoding:e.responseEncoding,cache:e.cache??"no-store",signal:e.signal,keepAlive:e.keepAlive,readYourWrites:e.readYourWrites}),{automaticDeserialization:e.automaticDeserialization,enableTelemetry:!process.env.UPSTASH_DISABLE_TELEMETRY,latencyLogging:e.latencyLogging,enableAutoPipelining:e.enableAutoPipelining}),this.addTelemetry({runtime:"string"==typeof EdgeRuntime?"edge-light":`node@${process.version}`,platform:process.env.UPSTASH_CONSOLE?"console":process.env.VERCEL?"vercel":process.env.AWS_REGION?"aws":"unknown",sdk:"@upstash/redis@v1.35.3"}),this.enableAutoPipelining)return this.autoPipeline()}static fromEnv(t){if(void 0===process.env)throw TypeError('[Upstash Redis] Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from "@upstash/redis/cloudflare" instead');let s=process.env.UPSTASH_REDIS_REST_URL||process.env.KV_REST_API_URL;s||console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_URL`");let n=process.env.UPSTASH_REDIS_REST_TOKEN||process.env.KV_REST_API_TOKEN;return n||console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`"),new e({...t,url:s,token:n})}};let i1=process.env.UPSTASH_REDIS_REST_URL&&process.env.UPSTASH_REDIS_REST_TOKEN,i2=i1?new i0({url:process.env.UPSTASH_REDIS_REST_URL,token:process.env.UPSTASH_REDIS_REST_TOKEN}):null,i3=i1&&i2?new tM.Ratelimit({redis:i2,limiter:tM.Ratelimit.slidingWindow(30,"1 d"),analytics:!0}):null;async function i4(e){try{let t,{base64Image:s}=await e.json();if(!s||"string"!=typeof s)return es.NextResponse.json({error:"Missing required field: base64Image"},{status:400});if(i3){let t=e.headers.get("x-forwarded-for")?.split(",")[0]||e.headers.get("x-real-ip")||"unknown",{success:s}=await i3.limit(t);if(!s)return es.NextResponse.json({error:"Rate limit exceeded",details:"You've reached the daily limit of 30 receipts. Contact @nutlope on X/Twitter for higher limits."},{status:429})}let n=tP.z.object({receipts:tP.z.array(tN)}),i=tP.z.toJSONSchema(n),r=await tI.chat.completions.create({model:"meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",messages:[{role:"system",content:`You are an expert at extracting receipt data. Extract all receipts from the image as a JSON object matching the schema.

CRITICAL FORMATTING REQUIREMENTS:
- Date MUST be in YYYY-MM-DD format (e.g., "2024-01-15", not "01/15/2024" or "Jan 15, 2024")
- Convert any date format to YYYY-MM-DD
- If date is ambiguous, use the most recent logical date

CURRENCY EXTRACTION:
- ALWAYS include a currency field in the response
- Extract the currency code (e.g., "USD", "EUR", "AED", "GBP", "CAD", etc.) from currency symbols or explicit mentions
- Common currency symbols: $ = USD,  = EUR, \xa3 = GBP, AED = AED (or .), etc.
- If no currency symbol is visible on the receipt, use "USD" as the default
- Currency field should be the 3-letter currency code (ISO 4217 format)

CATEGORIZATION RULES:
- Grocery stores (Walmart, Target, Kroger, Safeway, Whole Foods, Trader Joe's, Costco, Sam's Club, Aldi, Publix, Wegmans): "groceries"
- Restaurants/Fast food (McDonald's, Starbucks, Chipotle, Taco Bell, Subway, etc.): "dining"
- Gas stations (Shell, Exxon, Chevron, BP, Speedway, etc.): "gas"
- Pharmacies (CVS, Walgreens, Rite Aid, etc.): "healthcare"
- Department stores (Macy's, Kohl's, JCPenney, etc.): "shopping"
- Electronics (Best Buy, Apple Store, etc.): "electronics"
- Home improvement (Home Depot, Lowe's, etc.): "home"
- Clothing (Gap, Old Navy, H&M, etc.): "clothing"
- Online services (Amazon, eBay, etc.): "shopping"
- Utilities (electric, gas, water, internet): "utilities"
- Entertainment (movies, concerts, etc.): "entertainment"
- Travel (hotels, airlines, etc.): "travel"
- Other: Use your best judgment to categorize appropriately

PAYMENT METHODS: Common values include "cash", "credit", "debit", "check", "gift card", "digital wallet"

Extract all visible receipt data accurately. If information is not visible, use reasonable defaults or omit if not applicable. Respond only with valid JSON.`},{role:"user",content:[{type:"text",text:"Extract receipt data from this image following the formatting and categorization rules."},{type:"image_url",image_url:{url:`data:image/jpeg;base64,${s}`}}]}],response_format:{type:"json_object",schema:i}}),o=r?.choices?.[0]?.message?.content;if(!o)return es.NextResponse.json({error:"OCR extraction failed: empty response"},{status:502});try{t=JSON.parse(o)}catch(e){return es.NextResponse.json({error:"Invalid JSON from model"},{status:502})}let a=n.safeParse(t);if(!a.success)return console.error("OCR validation failed:",a.error.message),console.error("Raw response:",t),es.NextResponse.json({error:"Validation failed",details:a.error.message},{status:422});return es.NextResponse.json({receipts:a.data.receipts})}catch(e){return console.error("/api/ocr error",e),es.NextResponse.json({error:"Internal error while performing OCR"},{status:500})}}e.s(["POST",()=>i4],50447);var i5=e.i(50447);let i6=new j.AppRouteRouteModule({definition:{kind:$.RouteKind.APP_ROUTE,page:"/api/ocr/route",pathname:"/api/ocr",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/ocr/route.ts",nextConfigOutput:"standalone",userland:i5}),{workAsyncStorage:i8,workUnitAsyncStorage:i9,serverHooks:i7}=i6;function re(){return(0,z.patchFetch)({workAsyncStorage:i8,workUnitAsyncStorage:i9})}async function rt(e,t,s){i6.isDev&&(0,W.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let n="/api/ocr/route";n=n.replace(/\/index$/,"")||"/";let i=await i6.prepare(e,t,{srcPage:n,multiZoneDraftMode:!1});if(!i)return t.statusCode=400,t.end("Bad Request"),null==s.waitUntil||s.waitUntil.call(s,Promise.resolve()),null;let{buildId:r,params:o,nextConfig:a,parsedUrl:c,isDraftMode:l,prerenderManifest:h,routerServerContext:u,isOnDemandRevalidate:p,revalidateOnlyGenerated:d,resolvedPathname:m,clientReferenceManifest:f,serverActionsManifest:w}=i,g=(0,F.normalizeAppPath)(n),y=!!(h.dynamicRoutes[g]||h.routes[m]),x=async()=>((null==u?void 0:u.render404)?await u.render404(e,t,c,!1):t.end("This page could not be found"),null);if(y&&!l){let e=!!h.routes[m],t=h.dynamicRoutes[g];if(t&&!1===t.fallback&&!e){if(a.experimental.adapterPath)return await x();throw new ee.NoFallbackError}}let b=null;!y||i6.isDev||l||(b="/index"===(b=m)?"/":b);let v=!0===i6.isDev||!y,O=y&&!v;w&&f&&(0,B.setReferenceManifestsSingleton)({page:n,clientReferenceManifest:f,serverActionsManifest:w,serverModuleMap:(0,K.createServerModuleMap)({serverActionsManifest:w})});let E=e.method||"GET",R=(0,q.getTracer)(),S=R.getActiveScopeSpan(),k={params:o,prerenderManifest:h,renderOpts:{experimental:{authInterrupts:!!a.experimental.authInterrupts},cacheComponents:!!a.cacheComponents,supportsDynamicResponse:v,incrementalCache:(0,W.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:a.cacheLife,waitUntil:s.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,s,n)=>i6.onRequestError(e,t,n,u)},sharedContext:{buildId:r}},T=new G.NodeNextRequest(e),A=new G.NodeNextResponse(t),_=H.NextRequestAdapter.fromNodeNextRequest(T,(0,H.signalFromNodeResponse)(t));try{let i=async e=>i6.handle(_,k).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let s=R.getRootSpanAttributes();if(!s)return;if(s.get("next.span_type")!==V.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${s.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let i=s.get("next.route");if(i){let t=`${E} ${i}`;e.setAttributes({"next.route":i,"http.route":i,"next.span_name":t}),e.updateName(t)}else e.updateName(`${E} ${n}`)}),r=!!(0,W.getRequestMeta)(e,"minimalMode"),o=async o=>{var c,m;let f=async({previousCacheEntry:a})=>{try{if(!r&&p&&d&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await i(o);e.fetchMetrics=k.renderOpts.fetchMetrics;let c=k.renderOpts.pendingWaitUntil;c&&s.waitUntil&&(s.waitUntil(c),c=void 0);let l=k.renderOpts.collectedTags;if(!y)return await (0,Y.sendResponse)(T,A,n,k.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,X.toNodeOutgoingHttpHeaders)(n.headers);l&&(t[Q.NEXT_CACHE_TAGS_HEADER]=l),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let s=void 0!==k.renderOpts.collectedRevalidate&&!(k.renderOpts.collectedRevalidate>=Q.INFINITE_CACHE)&&k.renderOpts.collectedRevalidate,i=void 0===k.renderOpts.collectedExpire||k.renderOpts.collectedExpire>=Q.INFINITE_CACHE?void 0:k.renderOpts.collectedExpire;return{value:{kind:et.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:s,expire:i}}}}catch(t){throw(null==a?void 0:a.isStale)&&await i6.onRequestError(e,t,{routerKind:"App Router",routePath:n,routeType:"route",revalidateReason:(0,J.getRevalidateReason)({isStaticGeneration:O,isOnDemandRevalidate:p})},u),t}},w=await i6.handleResponse({req:e,nextConfig:a,cacheKey:b,routeKind:$.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:h,isRoutePPREnabled:!1,isOnDemandRevalidate:p,revalidateOnlyGenerated:d,responseGenerator:f,waitUntil:s.waitUntil,isMinimalMode:r});if(!y)return null;if((null==w||null==(c=w.value)?void 0:c.kind)!==et.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==w||null==(m=w.value)?void 0:m.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});r||t.setHeader("x-nextjs-cache",p?"REVALIDATED":w.isMiss?"MISS":w.isStale?"STALE":"HIT"),l&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let g=(0,X.fromNodeOutgoingHttpHeaders)(w.value.headers);return r&&y||g.delete(Q.NEXT_CACHE_TAGS_HEADER),!w.cacheControl||t.getHeader("Cache-Control")||g.get("Cache-Control")||g.set("Cache-Control",(0,Z.getCacheControlHeader)(w.cacheControl)),await (0,Y.sendResponse)(T,A,new Response(w.value.body,{headers:g,status:w.value.status||200})),null};S?await o(S):await R.withPropagatedContext(e.headers,()=>R.trace(V.BaseServerSpan.handleRequest,{spanName:`${E} ${n}`,kind:q.SpanKind.SERVER,attributes:{"http.method":E,"http.target":e.url}},o))}catch(t){if(t instanceof ee.NoFallbackError||await i6.onRequestError(e,t,{routerKind:"App Router",routePath:g,routeType:"route",revalidateReason:(0,J.getRevalidateReason)({isStaticGeneration:O,isOnDemandRevalidate:p})}),y)throw t;return await (0,Y.sendResponse)(T,A,new Response(null,{status:500})),null}}e.s(["handler",()=>rt,"patchFetch",()=>re,"routeModule",()=>i6,"serverHooks",()=>i7,"workAsyncStorage",()=>i8,"workUnitAsyncStorage",()=>i9],31329)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__e75203c7._.js.map